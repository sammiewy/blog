{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/images/touxiang.jpeg","path":"images/touxiang.jpeg","modified":0,"renderable":0},{"_id":"themes/concise/source/css/style.styl","path":"css/style.styl","modified":0,"renderable":1}],"Cache":[{"_id":"themes/concise/_config.yml","hash":"715ab206bf0e168645ab12d716516092b3f4faad","modified":1471780881000},{"_id":"themes/concise/LICENSE","hash":"e60dbb857cb3594b97fe2182e08e844a97f6f584","modified":1471773694000},{"_id":"themes/concise/npm-debug.log","hash":"6df346548140cc92068a0478023c3e859bd6231f","modified":1471773694000},{"_id":"themes/concise/README.md","hash":"325aadf4a51c6e0c0a2cbd50e3e46d60d4b049fa","modified":1471778880000},{"_id":"source/_posts/generator.md","hash":"a76d197d20b1bf769a3ab474b54c03ec9466a4ef","modified":1471782106000},{"_id":"source/_posts/createblog.md","hash":"81c103a928ae63fe80997bba576b1322a7d49633","modified":1471781049000},{"_id":"source/_posts/react-question.md","hash":"eb6c329c16f286ffd1248f60e934f9fcf536c0df","modified":1471781756000},{"_id":"source/categories/index.md","hash":"086b0fdff9721eaa90bd4ffde65ba1faa5b2731d","modified":1471779033000},{"_id":"source/images/touxiang.jpeg","hash":"8ab93b977f0d117b1a636eb11690d5f410f01d94","modified":1471779033000},{"_id":"source/tags/index.md","hash":"ae954247bf377e5d1e1e4e7cc197834f42e604c4","modified":1471779033000},{"_id":"themes/concise/languages/de.yml","hash":"e076c7f2eb29ebcfb04d94861bf3063c4b08078c","modified":1471773694000},{"_id":"themes/concise/languages/default.yml","hash":"4a0e5b645d93002ff810e245ebe3c72bb444d470","modified":1471773694000},{"_id":"themes/concise/languages/es.yml","hash":"de273af604b27812cfd4195e7b7f28ceff2734b3","modified":1471773694000},{"_id":"themes/concise/languages/no.yml","hash":"bf11017d77f64fbafb9c99ac219d076b20d53afc","modified":1471773694000},{"_id":"themes/concise/languages/pl.yml","hash":"3f36d08e84a85651bf777cec0752193057c08430","modified":1471773694000},{"_id":"themes/concise/languages/ru.yml","hash":"35aadf8fdd28aaff8a1c8f50e80201dcf8ce0604","modified":1471773694000},{"_id":"themes/concise/languages/zh-CN.yml","hash":"ca0118e9081b54cc0fca8596660bd6acf4c0308f","modified":1471773694000},{"_id":"themes/concise/layout/archive.ejs","hash":"a18842e3d719fe3ca9b977a6995f8facc75c8673","modified":1471773694000},{"_id":"themes/concise/layout/category.ejs","hash":"9b740fc33f6f028df60f0bc4312bf3ebd03aa8ea","modified":1471773694000},{"_id":"themes/concise/languages/zh-TW.yml","hash":"6141b4c7a094c74bd9df7c08908d92b561c1a0c0","modified":1471773694000},{"_id":"themes/concise/layout/layout.ejs","hash":"384fab2db2f95485f987996e7154cfdf61b9baf0","modified":1471773694000},{"_id":"themes/concise/layout/index.ejs","hash":"e569d8fe0741a24efb89e44781f9e616da17e036","modified":1471773694000},{"_id":"themes/concise/layout/page.ejs","hash":"70cbc9854655773cc6ba84eecaaf330fed430465","modified":1471773694000},{"_id":"themes/concise/layout/post.ejs","hash":"70cbc9854655773cc6ba84eecaaf330fed430465","modified":1471773694000},{"_id":"themes/concise/layout/tag.ejs","hash":"45150a2365768b6b67880193c9264ad2bb4814db","modified":1471773694000},{"_id":"themes/concise/layout/_partial/after_footer.ejs","hash":"cc996d8522636ce4ce9a9242e6819b4f2a5c93d4","modified":1471773694000},{"_id":"themes/concise/layout/_partial/archive.ejs","hash":"0e6ce7edc750696175e6460069aaae4b44b86df5","modified":1471773694000},{"_id":"themes/concise/layout/_partial/article.ejs","hash":"4360edc6cc6393a801dba3e80723a7895546d6da","modified":1471773694000},{"_id":"themes/concise/layout/_partial/comment.ejs","hash":"dd66c6ddc577f8fce2bcef6b2786a5085800fc40","modified":1471773694000},{"_id":"themes/concise/layout/_partial/footer.ejs","hash":"1deac5914b2fc93b271732fd4d5cbd0a6f78875f","modified":1471773694000},{"_id":"themes/concise/layout/_partial/google_analytics.ejs","hash":"7cf0d1f93051bda510d49dab7f684b9d7c6ba58f","modified":1471773694000},{"_id":"themes/concise/layout/_partial/head.ejs","hash":"be8e448588701358d98cda676988122e350426b1","modified":1471773694000},{"_id":"themes/concise/layout/_partial/header.ejs","hash":"f824521fa05f36946053b330de7988a5d840f7a6","modified":1471773694000},{"_id":"themes/concise/layout/_partial/pagination.ejs","hash":"1206b630a07444e8744365f14ddb26095c925ae1","modified":1471773694000},{"_id":"themes/concise/layout/_partial/sidebar.ejs","hash":"caf351797a18d03d8ee945ceb9f83785c50c09f9","modified":1471773694000},{"_id":"themes/concise/layout/_widget/category.ejs","hash":"8a2b90dc29661371f060f710668929c3588e15e4","modified":1471773694000},{"_id":"themes/concise/layout/_widget/recent_posts.ejs","hash":"f17d2cb69034acabea4df54f301f80812e7b84a8","modified":1471773694000},{"_id":"themes/concise/layout/_widget/search.ejs","hash":"55c707f3aa7453c305c41898ad22556edd213830","modified":1471773694000},{"_id":"themes/concise/layout/_widget/tag.ejs","hash":"1914db78bea49c333067d79fe7ad9567d2b08d00","modified":1471773694000},{"_id":"themes/concise/layout/_widget/tagcloud.ejs","hash":"a236c86481196ae43206e056ba78cec14f1ac014","modified":1471773694000},{"_id":"themes/concise/source/css/style.styl","hash":"c03b2520e4a85b981e29516cadc0a365e6500e3d","modified":1471773694000},{"_id":"themes/concise/source/css/_base/utils.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1471773694000},{"_id":"themes/concise/layout/_partial/post/category.ejs","hash":"be740939c5c2d4ffdbed9557b4e63a590058b476","modified":1471773694000},{"_id":"themes/concise/layout/_partial/post/gallery.ejs","hash":"fafc2501d7e65983b0f5c2b58151ca12e57c0574","modified":1471773694000},{"_id":"themes/concise/layout/_partial/post/share.ejs","hash":"24c04b319f1b19e887c42db961b90a7e0ab26fdc","modified":1471773694000},{"_id":"themes/concise/layout/_partial/post/tag.ejs","hash":"095418df66a27a28cbab16d7cb0d16001b0e23f1","modified":1471773694000},{"_id":"themes/concise/layout/_partial/post/title.ejs","hash":"d7fbc575d35ae68f9045a382c651450e4131f335","modified":1471773694000},{"_id":"themes/concise/source/css/_base/layout.styl","hash":"d8276f48d81da8281bb93494ac804ddc4c5d6276","modified":1471773694000},{"_id":"themes/concise/source/css/_base/variable.styl","hash":"f5a66b4cb5dd3c1da787796ed86f4a9466ff5089","modified":1471773694000},{"_id":"themes/concise/source/css/_partial/archive.styl","hash":"13f1a01c1d0fe4f3ee14347662a226771227a33c","modified":1471773694000},{"_id":"themes/concise/source/css/_partial/article.styl","hash":"84790de172e48c34bed0f4c7df2d94a2ecb8e5a4","modified":1471773694000},{"_id":"themes/concise/source/css/_partial/comment.styl","hash":"e7f8c085bfa8c26afc4b2fbc9f2092f4f07aef34","modified":1471773694000},{"_id":"themes/concise/source/css/_partial/footer.styl","hash":"1757872dbdbd09295a625f13e356aa798a8bb308","modified":1471773694000},{"_id":"themes/concise/source/css/_partial/header.styl","hash":"1d0c9800c041199a1b264fa4bf72deefef6fc3de","modified":1471773694000},{"_id":"themes/concise/source/css/_partial/sidebar.styl","hash":"42e745cd143dbad05cd07c1bcdd4162747f26506","modified":1471773694000},{"_id":"themes/concise/source/css/_partial/index.styl","hash":"b4cffb56b4ec4b7987d9682b48dec4e1ab3ca0c1","modified":1471773694000},{"_id":"themes/concise/source/css/_partial/syntax.styl","hash":"400335f01229ed02e62110ba90312adb78b84ff5","modified":1471773694000},{"_id":"public/categories/index.html","hash":"8e1295010adad95318bbbfb327badc1e68b610fb","modified":1471782171615},{"_id":"public/tags/index.html","hash":"5593a8a6d0ffd8d874281b1974bf60a1cededd55","modified":1471782171615},{"_id":"public/2016/04/09/createblog/index.html","hash":"18885d4a19363bf957709b6e51e6fc412be52987","modified":1471782171616},{"_id":"public/archives/index.html","hash":"538c20dc364b67794880909f2c531178d0b19a68","modified":1471782171616},{"_id":"public/archives/2016/index.html","hash":"c84726acfcb9b82bab9e61640972d51d904c5b77","modified":1471782171616},{"_id":"public/archives/2016/04/index.html","hash":"c6738fcff272fe6facb57bc6c1ca04616530a177","modified":1471782171616},{"_id":"public/archives/2016/06/index.html","hash":"517872938ae6adca535492b8b9d0e7230ef5417e","modified":1471782171616},{"_id":"public/categories/ES6/index.html","hash":"3248d97e8dc19a11d61b4babd0ebe3782c2caddf","modified":1471782171616},{"_id":"public/categories/技术/index.html","hash":"0ba0fd4e4109cc92b351403c7fc8cce0f4a88858","modified":1471782171617},{"_id":"public/categories/React/index.html","hash":"b21a1d82148d70f81f2243f2c1f6556977c9d2a1","modified":1471782171618},{"_id":"public/tags/ES6/index.html","hash":"9cff7c13e3c84a14a6d44798e2f86915bf6e2914","modified":1471782171618},{"_id":"public/tags/技术/index.html","hash":"fe72bdbd0a52c449679e41188557217e4695924f","modified":1471782171620},{"_id":"public/tags/ReactJS/index.html","hash":"43b5ccb377f0c8118f76945fa497640b3f330d6f","modified":1471782171620},{"_id":"public/2016/06/30/generator/index.html","hash":"ebdc6dee74a724f9809acfeaaaf1f06fadea86f8","modified":1471782171620},{"_id":"public/2016/06/21/react-question/index.html","hash":"b99f0f5eebccfd5e4699ed13f3c94a1a24be1fa8","modified":1471782171620},{"_id":"public/index.html","hash":"dfb01c32f60baece31a9cd20a6dee95ab6703d9b","modified":1471782171620},{"_id":"public/images/touxiang.jpeg","hash":"8ab93b977f0d117b1a636eb11690d5f410f01d94","modified":1471782171623},{"_id":"public/css/style.css","hash":"1f190e73a134200c5d52e28ebee6214e5471bb94","modified":1471782172572}],"Category":[{"name":"ES6","_id":"cis4l3qts00051hp45tfnpe1w"},{"name":"技术","_id":"cis4l3qtz00081hp4x0s0h9zq"},{"name":"React","_id":"cis4l3qu5000c1hp492zw6nqg"}],"Data":[],"Page":[{"title":"categories","date":"2016-04-09T15:22:27.000Z","type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2016-04-09 23:22:27\ntype: \"categories\"\n---\n","updated":"2016-08-21T11:30:33.000Z","path":"categories/index.html","comments":1,"layout":"page","_id":"cis4l3qt700011hp4p5cqb30c","content":"","excerpt":"","more":""},{"title":"tags","date":"2016-04-09T15:19:50.000Z","type":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2016-04-09 23:19:50\ntype: \"tags\"\n---\n","updated":"2016-08-21T11:30:33.000Z","path":"tags/index.html","comments":1,"layout":"page","_id":"cis4l3qtg00031hp4n7jrylxq","content":"","excerpt":"","more":""}],"Post":[{"title":"ES6中的Generator函数","date":"2016-06-30T12:10:10.000Z","_content":"\n#### 一、ES6简介\n ECMAScript 6（以下简称 ES6）是 JavaScript 语言的下一代标准，已经在 2015 年 6 月正式发布了。\n ES6中包含了许多新的语言特性，它们将使JS变得更加强大，更富表现力。\n\n##### 1、现状\n- 主流框架全面转向 ES6\n\n    [Angular 2](https://github.com/angular/angular)\n\n    [ReactJs](http://reactjs.cn/)\n\n    [koa](https://github.com/koajs/koa)\n- 兼容性 [对比表格](http://kangax.github.io/compat-table/es6/)\n\n##### 2、转码器\n转码器可以将ES6代码转为ES5代码，常用的转码器：[babel转码器](https://babeljs.io/)、\n[Traceur转码器](https://github.com/google/traceur-compiler) 、 [Traceur在线转码](http://google.github.io/traceur-compiler/demo/repl.html)\n\n##### 3、新特性\n- let and const命令\n-   Arrow Function箭头函数\n-  Destructuring Assignment （解构赋值）\n-  Generator函数\n-  Class\n-  Module\n-  Promise\n\n更多可参考[es6-features](http://es6-features.org/#Constants)\n\n#### 二、Generator函数\n在讲Generator之前，我们来说一下我们可能会遇到的这种场景：\n\n```\n// 第1个ajax请求\n$.ajax({\n    url: '/bankend/xxx/xxx',\n    dateType:'json',\n    type:'get',\n    data:{\n        data:JSON.stringify({status:1,data:'hello world'}),\n        type:'json',\n        timeout:1000\n    },\n    success:function(data){\n        if(data.status === 1){\n            // 第2个ajax请求\n            $.ajax({\n                ......此处省略500字\n                success:function(data){\n                    if(data.status === 1){\n                        // 第3个ajax请求\n                        $.ajax({\n                            ......此处省略500字\n                            success:function(data){\n                                if(data.status === 1){\n\n                                }\n                            }\n                        });\n                    }\n                }\n            });\n        }\n    }\n});\n```\n如果改用generator函数实现方式：\n\n```\nyield $.ajax(...); //第一个ajax请求\nyield $.ajax(...); //第二个ajax请求\nyield $.ajax(...); //第三个ajax请求\n......   //第n个请求 \n```\n这样的代码是不是让人看着更舒服一些。generator是如果实现的呢。首先我们得先了解一下generator的基本用法。\n\n##### 1、基本语法\nGenerator函数是ES6中的一种异步实现函数，它类似一种状态机，通过yield产生各种状态，通过next方法执行各种状态。\n\n基本语法如下:\n\n```\n//声明Generator函数\nfunction* gen() {\n    yield 1;\n    yield 2;\n    yield 3;\n    yield 4;\n}\n\n//调用\nvar  g = gen();\ng.next(); // {value: 1, done: false}\ng.next(); // {value: 2, done: false}\ng.next(); // {value: 3, done: false}\ng.next(); // {value: 4, done: false}\ng.next();  // {value: undefined, done: true}\ng.next(); //{value: undefined, done: true}\n```\n\n调用generator函数返回的是一个指向内部状态的指针对象，即遍历器对象;通过返回的遍历器对象的next方法，使得指针指向下一个状态。每次调用next方法时，内部指针就从函数头或上一次停下来的地方开始执行，直到遇到下一个状态（下一条yield语句或return语句）为止。\n\n如下图所示：\n\n![image](http://haitao.nos.netease.com/6ad3f9d783c244d59dc785bbde15e4bd.png)\n\n[Demo](http://people.mozilla.org/~jorendorff/demos/meow.html)\n\n##### 2、next方法参数、yield*语句\n\n###### （1）. next方法参数\nyield语句本身没有返回值，或者说总是返回undefined。next方法可以带一个参数，该参数会被当作上一条yield语句的返回值。不明白啥意思，来个栗子：\n\n```\nfunction add(num1, num2) {\n    return num1 + num2;\n}\n\nfunction* gen() {\n    var sum = add(yield 1, yield 3);\n    return sum;\n}\n\nvar g = gen();\ng.next(); //{ value: 1, done: false }\ng.next(); //{ value: 3, done: false }\ng.next(); //{ value: NaN, done: true }\ng.next(); //{ value: undefined, done: true }\n\n```\n\n```\nvar g = gen();\ng.next(); //{ value: 1, done: false }\ng.next(2); //{ value: 3, done: false }\ng.next(4); //{ value: 6, done: true }\ng.next(); //{ value: undefined, done: true }\n\n```\n\n###### （2）. yield*语句\n\n如果在Generator函数内部调用另外一个Generator函数，需要yield*语句。\n\n\n```\nfunction* innerGen() {\n    yield 2;\n    yield 3;\n}\n\nfunction* outGen() {\n    yield 1;\n    innerGen();\n    yield 4;\n}\n\nfunction* outGenYield() {\n    yield 1;\n    yield* innerGen();\n    yield 4;\n}\n```\n\n```\nvar g = outGen();\ng.next(); //{ value: 1, done: false }\ng.next(); //{ value: 4, done: false }\ng.next(); //{ value: undefined, done: true }\ng.next(); //{ value: undefined, done: true }\ng.next(); //{ value: undefined, done: true }\n\n\nvar outgen = outGenYield();\noutgen.next(); //{ value: 1, done: false }\noutgen.next(); //{ value: 2, done: false }\noutgen.next(); //{ value: 3, done: false }\noutgen.next(); //{ value: 4, done: false }\noutgen.next(); //{ value: undefined, done: true }\n\n```\n使用yield*语句，generator函数的状态变化如下图所示：\n![图2](http://haitao.nos.netease.com/a2d7daf768ca48ceb17eec9af02816e3.png)\n\n看下面例子输出什么：\n\n```\nfunction* gen() {\n    for (let i=0; i < 5; i++) {\n        console.log(i);\n        let temp = yield i;\n        console.log(i);\n        console.log(temp);\n    }\n}\nvar g = gen();\nconsole.log(g.next()); // ?\nconsole.log(g.next()); //?\nconsole.log(g.next()); // ?\nconsole.log(g.next()); // ?\nconsole.log(g.next()); // ?\nconsole.log(g.next()); // ?\n\n//输出结果？\n```\n\n##### 3、for...of循环、throw、return方法\n###### （1）. for...of循环\nfor...of循环可以自动遍历Generator函数，不需要再使用next方法。for...of只循环Generator的每个状态，不包含开始和结束节点。\n\n```\nfunction* gen() {\n    console.log(\"front 1\");\n    yield 1;\n    console.log(\"front 2\");\n    yield 2;\n    console.log(\"front 3\");\n    yield 3;\n    console.log(\"front 4\");\n    yield 4;\n    console.log(\"front 5\");\n    return 5;\n}\n\nfor (let v of gen()) {\n    console.log(v);\n}\n// 结果\nfront 1\n1\nfront 2\n2\nfront 3\n3\nfront 4\n4\nfront 5\n\n```\n###### （2）. throw方法\nGenerator函数返回的遍历器对象都有一个throw方法， Generator.prototype.throw(),可以在函数体外抛出错误，然后在Generator函数体内捕获。\n\n```\nvar g = function* () {\n  try {\n    yield;\n  } catch (e) {\n    console.log('内部捕获', e);\n  }\n};\n\nvar i = g();\ni.next();\n\ntry {\n  i.throw('a');\n  i.throw('b');\n} catch (e) {\n  console.log('外部捕获', e);\n}\n// 内部捕获 a\n// 外部捕获 b\n```\n\n###### （3）. return方法\nGenerator函数返回的遍历器对象还有一个return方法，返回给定的值，并终结Generator函数的遍历。\n```\nfunction* gen() {\n    yield 1;\n    yield 2;\n    yield 3;\n    return 4;\n}\n\nvar g = gen();\ng.next();  // {value: 1, done: false}\ng.return(6); //{value: 6, done: true}\ng.next();   //{valude: undefined, done: true}\n```\n#### 三、 应用\n##### 1. Generator实现异步\nGenerator函数可以暂停执行和恢复执行，这是它能封装异步任务的根本原因。\n\n来看一下开始的例子：\n\n```\nfunction* gen(){\n  yield $.ajax(...); //第一个ajax请求\n  yield $.ajax(...); //第二个ajax请求\n  yield $.ajax(...); //第三个ajax请求\n}\n\n```\n如果写成这样子我们改如何让请求一个个完成或再执行下一个请求呢。\n\n**思路：**\n当完成一个请求，我们再调用下一个next()执行下一个状态即下一个请求。\n\n```\nfunction next(err, data) {\n    var result = gen.next(data);\n    if (result.done) return;\n    result.value.then(function(){\n        next();\n    });\n}\nnext();\n```\n![image](http://haitao.nos.netease.com/8ec00addae2343d7871dcf23a1c58254.png)\n\n\nco就是上面那个自动执行器的扩展。[co模块源码](https://github.com/tj/co)\n用法:\n```\nco(function* () {\n  var result = yield Promise.resolve(true);\n  return result;\n}).then(function (value) {\n  console.log(value);\n}, function (err) {\n  console.error(err.stack);\n});\n\n```\n##### 2. koa框架\n[koa](http://koa.rednode.cn/)是由Express是Express原班人马打造的一个更小，基于nodejs平台的下一代web开发框架。Koa的精妙之处就在于其使用generator，实现了一种更为有趣的中间件系统，Koa的中间件是一系列generator函数的对象，执行起来有点类似于栈的结构，依次执行。\n\n当一个请求过来的时候，会依次经过各个中间件进行处理，中间件跳转的信号是yield next，当到某个中间件后，该中间件处理完不执行yield next的时候，然后就会逆序执行前面那些中间件剩下的逻辑。、\n\n总体架构图：\n\n![image](http://haitao.nos.netease.com/916ebdb8f2db4d05a47f3d35c4b6d3a4.png)\n\n\n内部实现图：\n![image](http://haitao.nos.netease.com/f2044faa49d944ed91c05d4264e766ef.png)\n\n\n直接上个官网的例子：\n\n```\nvar koa = require('koa');\nvar app = koa();\n\n// response-time中间件\napp.use(function *(next){\n  var start = new Date;\n  yield next;\n  var ms = new Date - start;\n  this.set('X-Response-Time', ms + 'ms');\n});\n\n// logger中间件\napp.use(function *(next){\n  var start = new Date;\n  yield next;\n  var ms = new Date - start;\n  console.log('%s %s - %s', this.method, this.url, ms);\n});\n\n// 响应中间件\napp.use(function *(){\n  this.body = 'Hello World';\n});\napp.listen(3000);\n\n```\n上面的执行顺序就是：\n\n请求 ==> response-time中间件 ==> logger中间件 ==> 响应中间件 ==> logger中间件 ==> response-time中间件 ==> 响应。\n\n更详细描述就是：请求进来，先进到response-time中间件，执行 var start = new Date; 然后遇到yield next，则暂停response-time中间件的执行，跳转进logger中间件，同理，最后进入响应中间件，响应中间件中没有yield next代码，则开始逆序执行，也就是再先是回到logger中间件，执行yield next之后的代码，执行完后再回到response-time中间件执行yield next之后的代码。\n\nkoa中间的实现原理：\n\n```\napp.use = function(fn){\n  if (!this.experimental) {\n    // es7 async functions are not allowed,\n    // so we have to make sure that `fn` is a generator function\n    assert(fn && 'GeneratorFunction' == fn.constructor.name, 'app.use() requires a generator function');\n  }\n  debug('use %s', fn._name || fn.name || '-');\n  this.middleware.push(fn);\n  return this;\n};\n\n\napp.callback = function(){\n  if (this.experimental) {\n    console.error('Experimental ES7 Async Function support is deprecated. Please look into Koa v2 as the middleware signature has changed.')\n  }\n  var fn = this.experimental\n    ? compose_es7(this.middleware)\n    : co.wrap(compose(this.middleware));\n  var self = this;\n\n  if (!this.listeners('error').length) this.on('error', this.onerror);\n\n  return function(req, res){\n    res.statusCode = 404;\n    var ctx = self.createContext(req, res);\n    onFinished(res, ctx.onerror);\n    fn.call(ctx).then(function () {\n      respond.call(ctx);\n    }).catch(ctx.onerror);\n  }\n};\n\nfunction compose(middleware){\n  return function *(next){\n    if (!next) next = noop();\n\n    var i = middleware.length;\n\n    while (i--) {\n      next = middleware[i].call(this, next);\n    }\n\n    return yield *next;\n  }\n}\n\n/**\n * Noop.\n *\n * @api private\n */\n\nfunction *noop(){}\n```\n\n参考文章：\n\n[原生httpServer、\nconnect、express简单介绍](https://github.com/alsotang/node-lessons/tree/master/lesson18)\n\n[koa源码](https://github.com/koajs/koa)\n","source":"_posts/generator.md","raw":"---\ntitle: ES6中的Generator函数\ndate: 2016-06-30 20:10:10\ntags: ES6\ncategories: ES6\n---\n\n#### 一、ES6简介\n ECMAScript 6（以下简称 ES6）是 JavaScript 语言的下一代标准，已经在 2015 年 6 月正式发布了。\n ES6中包含了许多新的语言特性，它们将使JS变得更加强大，更富表现力。\n\n##### 1、现状\n- 主流框架全面转向 ES6\n\n    [Angular 2](https://github.com/angular/angular)\n\n    [ReactJs](http://reactjs.cn/)\n\n    [koa](https://github.com/koajs/koa)\n- 兼容性 [对比表格](http://kangax.github.io/compat-table/es6/)\n\n##### 2、转码器\n转码器可以将ES6代码转为ES5代码，常用的转码器：[babel转码器](https://babeljs.io/)、\n[Traceur转码器](https://github.com/google/traceur-compiler) 、 [Traceur在线转码](http://google.github.io/traceur-compiler/demo/repl.html)\n\n##### 3、新特性\n- let and const命令\n-   Arrow Function箭头函数\n-  Destructuring Assignment （解构赋值）\n-  Generator函数\n-  Class\n-  Module\n-  Promise\n\n更多可参考[es6-features](http://es6-features.org/#Constants)\n\n#### 二、Generator函数\n在讲Generator之前，我们来说一下我们可能会遇到的这种场景：\n\n```\n// 第1个ajax请求\n$.ajax({\n    url: '/bankend/xxx/xxx',\n    dateType:'json',\n    type:'get',\n    data:{\n        data:JSON.stringify({status:1,data:'hello world'}),\n        type:'json',\n        timeout:1000\n    },\n    success:function(data){\n        if(data.status === 1){\n            // 第2个ajax请求\n            $.ajax({\n                ......此处省略500字\n                success:function(data){\n                    if(data.status === 1){\n                        // 第3个ajax请求\n                        $.ajax({\n                            ......此处省略500字\n                            success:function(data){\n                                if(data.status === 1){\n\n                                }\n                            }\n                        });\n                    }\n                }\n            });\n        }\n    }\n});\n```\n如果改用generator函数实现方式：\n\n```\nyield $.ajax(...); //第一个ajax请求\nyield $.ajax(...); //第二个ajax请求\nyield $.ajax(...); //第三个ajax请求\n......   //第n个请求 \n```\n这样的代码是不是让人看着更舒服一些。generator是如果实现的呢。首先我们得先了解一下generator的基本用法。\n\n##### 1、基本语法\nGenerator函数是ES6中的一种异步实现函数，它类似一种状态机，通过yield产生各种状态，通过next方法执行各种状态。\n\n基本语法如下:\n\n```\n//声明Generator函数\nfunction* gen() {\n    yield 1;\n    yield 2;\n    yield 3;\n    yield 4;\n}\n\n//调用\nvar  g = gen();\ng.next(); // {value: 1, done: false}\ng.next(); // {value: 2, done: false}\ng.next(); // {value: 3, done: false}\ng.next(); // {value: 4, done: false}\ng.next();  // {value: undefined, done: true}\ng.next(); //{value: undefined, done: true}\n```\n\n调用generator函数返回的是一个指向内部状态的指针对象，即遍历器对象;通过返回的遍历器对象的next方法，使得指针指向下一个状态。每次调用next方法时，内部指针就从函数头或上一次停下来的地方开始执行，直到遇到下一个状态（下一条yield语句或return语句）为止。\n\n如下图所示：\n\n![image](http://haitao.nos.netease.com/6ad3f9d783c244d59dc785bbde15e4bd.png)\n\n[Demo](http://people.mozilla.org/~jorendorff/demos/meow.html)\n\n##### 2、next方法参数、yield*语句\n\n###### （1）. next方法参数\nyield语句本身没有返回值，或者说总是返回undefined。next方法可以带一个参数，该参数会被当作上一条yield语句的返回值。不明白啥意思，来个栗子：\n\n```\nfunction add(num1, num2) {\n    return num1 + num2;\n}\n\nfunction* gen() {\n    var sum = add(yield 1, yield 3);\n    return sum;\n}\n\nvar g = gen();\ng.next(); //{ value: 1, done: false }\ng.next(); //{ value: 3, done: false }\ng.next(); //{ value: NaN, done: true }\ng.next(); //{ value: undefined, done: true }\n\n```\n\n```\nvar g = gen();\ng.next(); //{ value: 1, done: false }\ng.next(2); //{ value: 3, done: false }\ng.next(4); //{ value: 6, done: true }\ng.next(); //{ value: undefined, done: true }\n\n```\n\n###### （2）. yield*语句\n\n如果在Generator函数内部调用另外一个Generator函数，需要yield*语句。\n\n\n```\nfunction* innerGen() {\n    yield 2;\n    yield 3;\n}\n\nfunction* outGen() {\n    yield 1;\n    innerGen();\n    yield 4;\n}\n\nfunction* outGenYield() {\n    yield 1;\n    yield* innerGen();\n    yield 4;\n}\n```\n\n```\nvar g = outGen();\ng.next(); //{ value: 1, done: false }\ng.next(); //{ value: 4, done: false }\ng.next(); //{ value: undefined, done: true }\ng.next(); //{ value: undefined, done: true }\ng.next(); //{ value: undefined, done: true }\n\n\nvar outgen = outGenYield();\noutgen.next(); //{ value: 1, done: false }\noutgen.next(); //{ value: 2, done: false }\noutgen.next(); //{ value: 3, done: false }\noutgen.next(); //{ value: 4, done: false }\noutgen.next(); //{ value: undefined, done: true }\n\n```\n使用yield*语句，generator函数的状态变化如下图所示：\n![图2](http://haitao.nos.netease.com/a2d7daf768ca48ceb17eec9af02816e3.png)\n\n看下面例子输出什么：\n\n```\nfunction* gen() {\n    for (let i=0; i < 5; i++) {\n        console.log(i);\n        let temp = yield i;\n        console.log(i);\n        console.log(temp);\n    }\n}\nvar g = gen();\nconsole.log(g.next()); // ?\nconsole.log(g.next()); //?\nconsole.log(g.next()); // ?\nconsole.log(g.next()); // ?\nconsole.log(g.next()); // ?\nconsole.log(g.next()); // ?\n\n//输出结果？\n```\n\n##### 3、for...of循环、throw、return方法\n###### （1）. for...of循环\nfor...of循环可以自动遍历Generator函数，不需要再使用next方法。for...of只循环Generator的每个状态，不包含开始和结束节点。\n\n```\nfunction* gen() {\n    console.log(\"front 1\");\n    yield 1;\n    console.log(\"front 2\");\n    yield 2;\n    console.log(\"front 3\");\n    yield 3;\n    console.log(\"front 4\");\n    yield 4;\n    console.log(\"front 5\");\n    return 5;\n}\n\nfor (let v of gen()) {\n    console.log(v);\n}\n// 结果\nfront 1\n1\nfront 2\n2\nfront 3\n3\nfront 4\n4\nfront 5\n\n```\n###### （2）. throw方法\nGenerator函数返回的遍历器对象都有一个throw方法， Generator.prototype.throw(),可以在函数体外抛出错误，然后在Generator函数体内捕获。\n\n```\nvar g = function* () {\n  try {\n    yield;\n  } catch (e) {\n    console.log('内部捕获', e);\n  }\n};\n\nvar i = g();\ni.next();\n\ntry {\n  i.throw('a');\n  i.throw('b');\n} catch (e) {\n  console.log('外部捕获', e);\n}\n// 内部捕获 a\n// 外部捕获 b\n```\n\n###### （3）. return方法\nGenerator函数返回的遍历器对象还有一个return方法，返回给定的值，并终结Generator函数的遍历。\n```\nfunction* gen() {\n    yield 1;\n    yield 2;\n    yield 3;\n    return 4;\n}\n\nvar g = gen();\ng.next();  // {value: 1, done: false}\ng.return(6); //{value: 6, done: true}\ng.next();   //{valude: undefined, done: true}\n```\n#### 三、 应用\n##### 1. Generator实现异步\nGenerator函数可以暂停执行和恢复执行，这是它能封装异步任务的根本原因。\n\n来看一下开始的例子：\n\n```\nfunction* gen(){\n  yield $.ajax(...); //第一个ajax请求\n  yield $.ajax(...); //第二个ajax请求\n  yield $.ajax(...); //第三个ajax请求\n}\n\n```\n如果写成这样子我们改如何让请求一个个完成或再执行下一个请求呢。\n\n**思路：**\n当完成一个请求，我们再调用下一个next()执行下一个状态即下一个请求。\n\n```\nfunction next(err, data) {\n    var result = gen.next(data);\n    if (result.done) return;\n    result.value.then(function(){\n        next();\n    });\n}\nnext();\n```\n![image](http://haitao.nos.netease.com/8ec00addae2343d7871dcf23a1c58254.png)\n\n\nco就是上面那个自动执行器的扩展。[co模块源码](https://github.com/tj/co)\n用法:\n```\nco(function* () {\n  var result = yield Promise.resolve(true);\n  return result;\n}).then(function (value) {\n  console.log(value);\n}, function (err) {\n  console.error(err.stack);\n});\n\n```\n##### 2. koa框架\n[koa](http://koa.rednode.cn/)是由Express是Express原班人马打造的一个更小，基于nodejs平台的下一代web开发框架。Koa的精妙之处就在于其使用generator，实现了一种更为有趣的中间件系统，Koa的中间件是一系列generator函数的对象，执行起来有点类似于栈的结构，依次执行。\n\n当一个请求过来的时候，会依次经过各个中间件进行处理，中间件跳转的信号是yield next，当到某个中间件后，该中间件处理完不执行yield next的时候，然后就会逆序执行前面那些中间件剩下的逻辑。、\n\n总体架构图：\n\n![image](http://haitao.nos.netease.com/916ebdb8f2db4d05a47f3d35c4b6d3a4.png)\n\n\n内部实现图：\n![image](http://haitao.nos.netease.com/f2044faa49d944ed91c05d4264e766ef.png)\n\n\n直接上个官网的例子：\n\n```\nvar koa = require('koa');\nvar app = koa();\n\n// response-time中间件\napp.use(function *(next){\n  var start = new Date;\n  yield next;\n  var ms = new Date - start;\n  this.set('X-Response-Time', ms + 'ms');\n});\n\n// logger中间件\napp.use(function *(next){\n  var start = new Date;\n  yield next;\n  var ms = new Date - start;\n  console.log('%s %s - %s', this.method, this.url, ms);\n});\n\n// 响应中间件\napp.use(function *(){\n  this.body = 'Hello World';\n});\napp.listen(3000);\n\n```\n上面的执行顺序就是：\n\n请求 ==> response-time中间件 ==> logger中间件 ==> 响应中间件 ==> logger中间件 ==> response-time中间件 ==> 响应。\n\n更详细描述就是：请求进来，先进到response-time中间件，执行 var start = new Date; 然后遇到yield next，则暂停response-time中间件的执行，跳转进logger中间件，同理，最后进入响应中间件，响应中间件中没有yield next代码，则开始逆序执行，也就是再先是回到logger中间件，执行yield next之后的代码，执行完后再回到response-time中间件执行yield next之后的代码。\n\nkoa中间的实现原理：\n\n```\napp.use = function(fn){\n  if (!this.experimental) {\n    // es7 async functions are not allowed,\n    // so we have to make sure that `fn` is a generator function\n    assert(fn && 'GeneratorFunction' == fn.constructor.name, 'app.use() requires a generator function');\n  }\n  debug('use %s', fn._name || fn.name || '-');\n  this.middleware.push(fn);\n  return this;\n};\n\n\napp.callback = function(){\n  if (this.experimental) {\n    console.error('Experimental ES7 Async Function support is deprecated. Please look into Koa v2 as the middleware signature has changed.')\n  }\n  var fn = this.experimental\n    ? compose_es7(this.middleware)\n    : co.wrap(compose(this.middleware));\n  var self = this;\n\n  if (!this.listeners('error').length) this.on('error', this.onerror);\n\n  return function(req, res){\n    res.statusCode = 404;\n    var ctx = self.createContext(req, res);\n    onFinished(res, ctx.onerror);\n    fn.call(ctx).then(function () {\n      respond.call(ctx);\n    }).catch(ctx.onerror);\n  }\n};\n\nfunction compose(middleware){\n  return function *(next){\n    if (!next) next = noop();\n\n    var i = middleware.length;\n\n    while (i--) {\n      next = middleware[i].call(this, next);\n    }\n\n    return yield *next;\n  }\n}\n\n/**\n * Noop.\n *\n * @api private\n */\n\nfunction *noop(){}\n```\n\n参考文章：\n\n[原生httpServer、\nconnect、express简单介绍](https://github.com/alsotang/node-lessons/tree/master/lesson18)\n\n[koa源码](https://github.com/koajs/koa)\n","slug":"generator","published":1,"updated":"2016-08-21T12:21:46.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cis4l3qsy00001hp4lplptab3","content":"<h4 id=\"一、ES6简介\"><a href=\"#一、ES6简介\" class=\"headerlink\" title=\"一、ES6简介\"></a>一、ES6简介</h4><p> ECMAScript 6（以下简称 ES6）是 JavaScript 语言的下一代标准，已经在 2015 年 6 月正式发布了。<br> ES6中包含了许多新的语言特性，它们将使JS变得更加强大，更富表现力。</p>\n<h5 id=\"1、现状\"><a href=\"#1、现状\" class=\"headerlink\" title=\"1、现状\"></a>1、现状</h5><ul>\n<li><p>主流框架全面转向 ES6</p>\n<p>  <a href=\"https://github.com/angular/angular\" target=\"_blank\" rel=\"external\">Angular 2</a></p>\n<p>  <a href=\"http://reactjs.cn/\" target=\"_blank\" rel=\"external\">ReactJs</a></p>\n<p>  <a href=\"https://github.com/koajs/koa\" target=\"_blank\" rel=\"external\">koa</a></p>\n</li>\n<li>兼容性 <a href=\"http://kangax.github.io/compat-table/es6/\" target=\"_blank\" rel=\"external\">对比表格</a></li>\n</ul>\n<h5 id=\"2、转码器\"><a href=\"#2、转码器\" class=\"headerlink\" title=\"2、转码器\"></a>2、转码器</h5><p>转码器可以将ES6代码转为ES5代码，常用的转码器：<a href=\"https://babeljs.io/\" target=\"_blank\" rel=\"external\">babel转码器</a>、<br><a href=\"https://github.com/google/traceur-compiler\" target=\"_blank\" rel=\"external\">Traceur转码器</a> 、 <a href=\"http://google.github.io/traceur-compiler/demo/repl.html\" target=\"_blank\" rel=\"external\">Traceur在线转码</a></p>\n<h5 id=\"3、新特性\"><a href=\"#3、新特性\" class=\"headerlink\" title=\"3、新特性\"></a>3、新特性</h5><ul>\n<li>let and const命令</li>\n<li>Arrow Function箭头函数</li>\n<li>Destructuring Assignment （解构赋值）</li>\n<li>Generator函数</li>\n<li>Class</li>\n<li>Module</li>\n<li>Promise</li>\n</ul>\n<p>更多可参考<a href=\"http://es6-features.org/#Constants\" target=\"_blank\" rel=\"external\">es6-features</a></p>\n<h4 id=\"二、Generator函数\"><a href=\"#二、Generator函数\" class=\"headerlink\" title=\"二、Generator函数\"></a>二、Generator函数</h4><p>在讲Generator之前，我们来说一下我们可能会遇到的这种场景：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 第1个ajax请求</div><div class=\"line\">$.ajax(&#123;</div><div class=\"line\">    url: &apos;/bankend/xxx/xxx&apos;,</div><div class=\"line\">    dateType:&apos;json&apos;,</div><div class=\"line\">    type:&apos;get&apos;,</div><div class=\"line\">    data:&#123;</div><div class=\"line\">        data:JSON.stringify(&#123;status:1,data:&apos;hello world&apos;&#125;),</div><div class=\"line\">        type:&apos;json&apos;,</div><div class=\"line\">        timeout:1000</div><div class=\"line\">    &#125;,</div><div class=\"line\">    success:function(data)&#123;</div><div class=\"line\">        if(data.status === 1)&#123;</div><div class=\"line\">            // 第2个ajax请求</div><div class=\"line\">            $.ajax(&#123;</div><div class=\"line\">                ......此处省略500字</div><div class=\"line\">                success:function(data)&#123;</div><div class=\"line\">                    if(data.status === 1)&#123;</div><div class=\"line\">                        // 第3个ajax请求</div><div class=\"line\">                        $.ajax(&#123;</div><div class=\"line\">                            ......此处省略500字</div><div class=\"line\">                            success:function(data)&#123;</div><div class=\"line\">                                if(data.status === 1)&#123;</div><div class=\"line\"></div><div class=\"line\">                                &#125;</div><div class=\"line\">                            &#125;</div><div class=\"line\">                        &#125;);</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>如果改用generator函数实现方式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">yield $.ajax(...); //第一个ajax请求</div><div class=\"line\">yield $.ajax(...); //第二个ajax请求</div><div class=\"line\">yield $.ajax(...); //第三个ajax请求</div><div class=\"line\">......   //第n个请求</div></pre></td></tr></table></figure>\n<p>这样的代码是不是让人看着更舒服一些。generator是如果实现的呢。首先我们得先了解一下generator的基本用法。</p>\n<h5 id=\"1、基本语法\"><a href=\"#1、基本语法\" class=\"headerlink\" title=\"1、基本语法\"></a>1、基本语法</h5><p>Generator函数是ES6中的一种异步实现函数，它类似一种状态机，通过yield产生各种状态，通过next方法执行各种状态。</p>\n<p>基本语法如下:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">//声明Generator函数</div><div class=\"line\">function* gen() &#123;</div><div class=\"line\">    yield 1;</div><div class=\"line\">    yield 2;</div><div class=\"line\">    yield 3;</div><div class=\"line\">    yield 4;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">//调用</div><div class=\"line\">var  g = gen();</div><div class=\"line\">g.next(); // &#123;value: 1, done: false&#125;</div><div class=\"line\">g.next(); // &#123;value: 2, done: false&#125;</div><div class=\"line\">g.next(); // &#123;value: 3, done: false&#125;</div><div class=\"line\">g.next(); // &#123;value: 4, done: false&#125;</div><div class=\"line\">g.next();  // &#123;value: undefined, done: true&#125;</div><div class=\"line\">g.next(); //&#123;value: undefined, done: true&#125;</div></pre></td></tr></table></figure>\n<p>调用generator函数返回的是一个指向内部状态的指针对象，即遍历器对象;通过返回的遍历器对象的next方法，使得指针指向下一个状态。每次调用next方法时，内部指针就从函数头或上一次停下来的地方开始执行，直到遇到下一个状态（下一条yield语句或return语句）为止。</p>\n<p>如下图所示：</p>\n<p><img src=\"http://haitao.nos.netease.com/6ad3f9d783c244d59dc785bbde15e4bd.png\" alt=\"image\"></p>\n<p><a href=\"http://people.mozilla.org/~jorendorff/demos/meow.html\" target=\"_blank\" rel=\"external\">Demo</a></p>\n<h5 id=\"2、next方法参数、yield-语句\"><a href=\"#2、next方法参数、yield-语句\" class=\"headerlink\" title=\"2、next方法参数、yield*语句\"></a>2、next方法参数、yield*语句</h5><h6 id=\"（1）-next方法参数\"><a href=\"#（1）-next方法参数\" class=\"headerlink\" title=\"（1）. next方法参数\"></a>（1）. next方法参数</h6><p>yield语句本身没有返回值，或者说总是返回undefined。next方法可以带一个参数，该参数会被当作上一条yield语句的返回值。不明白啥意思，来个栗子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">function add(num1, num2) &#123;</div><div class=\"line\">    return num1 + num2;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">function* gen() &#123;</div><div class=\"line\">    var sum = add(yield 1, yield 3);</div><div class=\"line\">    return sum;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">var g = gen();</div><div class=\"line\">g.next(); //&#123; value: 1, done: false &#125;</div><div class=\"line\">g.next(); //&#123; value: 3, done: false &#125;</div><div class=\"line\">g.next(); //&#123; value: NaN, done: true &#125;</div><div class=\"line\">g.next(); //&#123; value: undefined, done: true &#125;</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">var g = gen();</div><div class=\"line\">g.next(); //&#123; value: 1, done: false &#125;</div><div class=\"line\">g.next(2); //&#123; value: 3, done: false &#125;</div><div class=\"line\">g.next(4); //&#123; value: 6, done: true &#125;</div><div class=\"line\">g.next(); //&#123; value: undefined, done: true &#125;</div></pre></td></tr></table></figure>\n<h6 id=\"（2）-yield-语句\"><a href=\"#（2）-yield-语句\" class=\"headerlink\" title=\"（2）. yield*语句\"></a>（2）. yield*语句</h6><p>如果在Generator函数内部调用另外一个Generator函数，需要yield*语句。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">function* innerGen() &#123;</div><div class=\"line\">    yield 2;</div><div class=\"line\">    yield 3;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">function* outGen() &#123;</div><div class=\"line\">    yield 1;</div><div class=\"line\">    innerGen();</div><div class=\"line\">    yield 4;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">function* outGenYield() &#123;</div><div class=\"line\">    yield 1;</div><div class=\"line\">    yield* innerGen();</div><div class=\"line\">    yield 4;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">var g = outGen();</div><div class=\"line\">g.next(); //&#123; value: 1, done: false &#125;</div><div class=\"line\">g.next(); //&#123; value: 4, done: false &#125;</div><div class=\"line\">g.next(); //&#123; value: undefined, done: true &#125;</div><div class=\"line\">g.next(); //&#123; value: undefined, done: true &#125;</div><div class=\"line\">g.next(); //&#123; value: undefined, done: true &#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">var outgen = outGenYield();</div><div class=\"line\">outgen.next(); //&#123; value: 1, done: false &#125;</div><div class=\"line\">outgen.next(); //&#123; value: 2, done: false &#125;</div><div class=\"line\">outgen.next(); //&#123; value: 3, done: false &#125;</div><div class=\"line\">outgen.next(); //&#123; value: 4, done: false &#125;</div><div class=\"line\">outgen.next(); //&#123; value: undefined, done: true &#125;</div></pre></td></tr></table></figure>\n<p>使用yield*语句，generator函数的状态变化如下图所示：<br><img src=\"http://haitao.nos.netease.com/a2d7daf768ca48ceb17eec9af02816e3.png\" alt=\"图2\"></p>\n<p>看下面例子输出什么：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">function* gen() &#123;</div><div class=\"line\">    for (let i=0; i &lt; 5; i++) &#123;</div><div class=\"line\">        console.log(i);</div><div class=\"line\">        let temp = yield i;</div><div class=\"line\">        console.log(i);</div><div class=\"line\">        console.log(temp);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">var g = gen();</div><div class=\"line\">console.log(g.next()); // ?</div><div class=\"line\">console.log(g.next()); //?</div><div class=\"line\">console.log(g.next()); // ?</div><div class=\"line\">console.log(g.next()); // ?</div><div class=\"line\">console.log(g.next()); // ?</div><div class=\"line\">console.log(g.next()); // ?</div><div class=\"line\"></div><div class=\"line\">//输出结果？</div></pre></td></tr></table></figure>\n<h5 id=\"3、for…of循环、throw、return方法\"><a href=\"#3、for…of循环、throw、return方法\" class=\"headerlink\" title=\"3、for…of循环、throw、return方法\"></a>3、for…of循环、throw、return方法</h5><h6 id=\"（1）-for…of循环\"><a href=\"#（1）-for…of循环\" class=\"headerlink\" title=\"（1）. for…of循环\"></a>（1）. for…of循环</h6><p>for…of循环可以自动遍历Generator函数，不需要再使用next方法。for…of只循环Generator的每个状态，不包含开始和结束节点。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\">function* gen() &#123;</div><div class=\"line\">    console.log(&quot;front 1&quot;);</div><div class=\"line\">    yield 1;</div><div class=\"line\">    console.log(&quot;front 2&quot;);</div><div class=\"line\">    yield 2;</div><div class=\"line\">    console.log(&quot;front 3&quot;);</div><div class=\"line\">    yield 3;</div><div class=\"line\">    console.log(&quot;front 4&quot;);</div><div class=\"line\">    yield 4;</div><div class=\"line\">    console.log(&quot;front 5&quot;);</div><div class=\"line\">    return 5;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">for (let v of gen()) &#123;</div><div class=\"line\">    console.log(v);</div><div class=\"line\">&#125;</div><div class=\"line\">// 结果</div><div class=\"line\">front 1</div><div class=\"line\">1</div><div class=\"line\">front 2</div><div class=\"line\">2</div><div class=\"line\">front 3</div><div class=\"line\">3</div><div class=\"line\">front 4</div><div class=\"line\">4</div><div class=\"line\">front 5</div></pre></td></tr></table></figure>\n<h6 id=\"（2）-throw方法\"><a href=\"#（2）-throw方法\" class=\"headerlink\" title=\"（2）. throw方法\"></a>（2）. throw方法</h6><p>Generator函数返回的遍历器对象都有一个throw方法， Generator.prototype.throw(),可以在函数体外抛出错误，然后在Generator函数体内捕获。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">var g = function* () &#123;</div><div class=\"line\">  try &#123;</div><div class=\"line\">    yield;</div><div class=\"line\">  &#125; catch (e) &#123;</div><div class=\"line\">    console.log(&apos;内部捕获&apos;, e);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">var i = g();</div><div class=\"line\">i.next();</div><div class=\"line\"></div><div class=\"line\">try &#123;</div><div class=\"line\">  i.throw(&apos;a&apos;);</div><div class=\"line\">  i.throw(&apos;b&apos;);</div><div class=\"line\">&#125; catch (e) &#123;</div><div class=\"line\">  console.log(&apos;外部捕获&apos;, e);</div><div class=\"line\">&#125;</div><div class=\"line\">// 内部捕获 a</div><div class=\"line\">// 外部捕获 b</div></pre></td></tr></table></figure>\n<h6 id=\"（3）-return方法\"><a href=\"#（3）-return方法\" class=\"headerlink\" title=\"（3）. return方法\"></a>（3）. return方法</h6><p>Generator函数返回的遍历器对象还有一个return方法，返回给定的值，并终结Generator函数的遍历。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">function* gen() &#123;</div><div class=\"line\">    yield 1;</div><div class=\"line\">    yield 2;</div><div class=\"line\">    yield 3;</div><div class=\"line\">    return 4;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">var g = gen();</div><div class=\"line\">g.next();  // &#123;value: 1, done: false&#125;</div><div class=\"line\">g.return(6); //&#123;value: 6, done: true&#125;</div><div class=\"line\">g.next();   //&#123;valude: undefined, done: true&#125;</div></pre></td></tr></table></figure></p>\n<h4 id=\"三、-应用\"><a href=\"#三、-应用\" class=\"headerlink\" title=\"三、 应用\"></a>三、 应用</h4><h5 id=\"1-Generator实现异步\"><a href=\"#1-Generator实现异步\" class=\"headerlink\" title=\"1. Generator实现异步\"></a>1. Generator实现异步</h5><p>Generator函数可以暂停执行和恢复执行，这是它能封装异步任务的根本原因。</p>\n<p>来看一下开始的例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">function* gen()&#123;</div><div class=\"line\">  yield $.ajax(...); //第一个ajax请求</div><div class=\"line\">  yield $.ajax(...); //第二个ajax请求</div><div class=\"line\">  yield $.ajax(...); //第三个ajax请求</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>如果写成这样子我们改如何让请求一个个完成或再执行下一个请求呢。</p>\n<p><strong>思路：</strong><br>当完成一个请求，我们再调用下一个next()执行下一个状态即下一个请求。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">function next(err, data) &#123;</div><div class=\"line\">    var result = gen.next(data);</div><div class=\"line\">    if (result.done) return;</div><div class=\"line\">    result.value.then(function()&#123;</div><div class=\"line\">        next();</div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;</div><div class=\"line\">next();</div></pre></td></tr></table></figure>\n<p><img src=\"http://haitao.nos.netease.com/8ec00addae2343d7871dcf23a1c58254.png\" alt=\"image\"></p>\n<p>co就是上面那个自动执行器的扩展。<a href=\"https://github.com/tj/co\" target=\"_blank\" rel=\"external\">co模块源码</a><br>用法:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">co(function* () &#123;</div><div class=\"line\">  var result = yield Promise.resolve(true);</div><div class=\"line\">  return result;</div><div class=\"line\">&#125;).then(function (value) &#123;</div><div class=\"line\">  console.log(value);</div><div class=\"line\">&#125;, function (err) &#123;</div><div class=\"line\">  console.error(err.stack);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<h5 id=\"2-koa框架\"><a href=\"#2-koa框架\" class=\"headerlink\" title=\"2. koa框架\"></a>2. koa框架</h5><p><a href=\"http://koa.rednode.cn/\" target=\"_blank\" rel=\"external\">koa</a>是由Express是Express原班人马打造的一个更小，基于nodejs平台的下一代web开发框架。Koa的精妙之处就在于其使用generator，实现了一种更为有趣的中间件系统，Koa的中间件是一系列generator函数的对象，执行起来有点类似于栈的结构，依次执行。</p>\n<p>当一个请求过来的时候，会依次经过各个中间件进行处理，中间件跳转的信号是yield next，当到某个中间件后，该中间件处理完不执行yield next的时候，然后就会逆序执行前面那些中间件剩下的逻辑。、</p>\n<p>总体架构图：</p>\n<p><img src=\"http://haitao.nos.netease.com/916ebdb8f2db4d05a47f3d35c4b6d3a4.png\" alt=\"image\"></p>\n<p>内部实现图：<br><img src=\"http://haitao.nos.netease.com/f2044faa49d944ed91c05d4264e766ef.png\" alt=\"image\"></p>\n<p>直接上个官网的例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\">var koa = require(&apos;koa&apos;);</div><div class=\"line\">var app = koa();</div><div class=\"line\"></div><div class=\"line\">// response-time中间件</div><div class=\"line\">app.use(function *(next)&#123;</div><div class=\"line\">  var start = new Date;</div><div class=\"line\">  yield next;</div><div class=\"line\">  var ms = new Date - start;</div><div class=\"line\">  this.set(&apos;X-Response-Time&apos;, ms + &apos;ms&apos;);</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">// logger中间件</div><div class=\"line\">app.use(function *(next)&#123;</div><div class=\"line\">  var start = new Date;</div><div class=\"line\">  yield next;</div><div class=\"line\">  var ms = new Date - start;</div><div class=\"line\">  console.log(&apos;%s %s - %s&apos;, this.method, this.url, ms);</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">// 响应中间件</div><div class=\"line\">app.use(function *()&#123;</div><div class=\"line\">  this.body = &apos;Hello World&apos;;</div><div class=\"line\">&#125;);</div><div class=\"line\">app.listen(3000);</div></pre></td></tr></table></figure>\n<p>上面的执行顺序就是：</p>\n<p>请求 ==&gt; response-time中间件 ==&gt; logger中间件 ==&gt; 响应中间件 ==&gt; logger中间件 ==&gt; response-time中间件 ==&gt; 响应。</p>\n<p>更详细描述就是：请求进来，先进到response-time中间件，执行 var start = new Date; 然后遇到yield next，则暂停response-time中间件的执行，跳转进logger中间件，同理，最后进入响应中间件，响应中间件中没有yield next代码，则开始逆序执行，也就是再先是回到logger中间件，执行yield next之后的代码，执行完后再回到response-time中间件执行yield next之后的代码。</p>\n<p>koa中间的实现原理：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div></pre></td><td class=\"code\"><pre><div class=\"line\">app.use = function(fn)&#123;</div><div class=\"line\">  if (!this.experimental) &#123;</div><div class=\"line\">    // es7 async functions are not allowed,</div><div class=\"line\">    // so we have to make sure that `fn` is a generator function</div><div class=\"line\">    assert(fn &amp;&amp; &apos;GeneratorFunction&apos; == fn.constructor.name, &apos;app.use() requires a generator function&apos;);</div><div class=\"line\">  &#125;</div><div class=\"line\">  debug(&apos;use %s&apos;, fn._name || fn.name || &apos;-&apos;);</div><div class=\"line\">  this.middleware.push(fn);</div><div class=\"line\">  return this;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">app.callback = function()&#123;</div><div class=\"line\">  if (this.experimental) &#123;</div><div class=\"line\">    console.error(&apos;Experimental ES7 Async Function support is deprecated. Please look into Koa v2 as the middleware signature has changed.&apos;)</div><div class=\"line\">  &#125;</div><div class=\"line\">  var fn = this.experimental</div><div class=\"line\">    ? compose_es7(this.middleware)</div><div class=\"line\">    : co.wrap(compose(this.middleware));</div><div class=\"line\">  var self = this;</div><div class=\"line\"></div><div class=\"line\">  if (!this.listeners(&apos;error&apos;).length) this.on(&apos;error&apos;, this.onerror);</div><div class=\"line\"></div><div class=\"line\">  return function(req, res)&#123;</div><div class=\"line\">    res.statusCode = 404;</div><div class=\"line\">    var ctx = self.createContext(req, res);</div><div class=\"line\">    onFinished(res, ctx.onerror);</div><div class=\"line\">    fn.call(ctx).then(function () &#123;</div><div class=\"line\">      respond.call(ctx);</div><div class=\"line\">    &#125;).catch(ctx.onerror);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">function compose(middleware)&#123;</div><div class=\"line\">  return function *(next)&#123;</div><div class=\"line\">    if (!next) next = noop();</div><div class=\"line\"></div><div class=\"line\">    var i = middleware.length;</div><div class=\"line\"></div><div class=\"line\">    while (i--) &#123;</div><div class=\"line\">      next = middleware[i].call(this, next);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    return yield *next;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">/**</div><div class=\"line\"> * Noop.</div><div class=\"line\"> *</div><div class=\"line\"> * @api private</div><div class=\"line\"> */</div><div class=\"line\"></div><div class=\"line\">function *noop()&#123;&#125;</div></pre></td></tr></table></figure>\n<p>参考文章：</p>\n<p><a href=\"https://github.com/alsotang/node-lessons/tree/master/lesson18\" target=\"_blank\" rel=\"external\">原生httpServer、<br>connect、express简单介绍</a></p>\n<p><a href=\"https://github.com/koajs/koa\" target=\"_blank\" rel=\"external\">koa源码</a></p>\n","excerpt":"","more":"<h4 id=\"一、ES6简介\"><a href=\"#一、ES6简介\" class=\"headerlink\" title=\"一、ES6简介\"></a>一、ES6简介</h4><p> ECMAScript 6（以下简称 ES6）是 JavaScript 语言的下一代标准，已经在 2015 年 6 月正式发布了。<br> ES6中包含了许多新的语言特性，它们将使JS变得更加强大，更富表现力。</p>\n<h5 id=\"1、现状\"><a href=\"#1、现状\" class=\"headerlink\" title=\"1、现状\"></a>1、现状</h5><ul>\n<li><p>主流框架全面转向 ES6</p>\n<p>  <a href=\"https://github.com/angular/angular\">Angular 2</a></p>\n<p>  <a href=\"http://reactjs.cn/\">ReactJs</a></p>\n<p>  <a href=\"https://github.com/koajs/koa\">koa</a></p>\n</li>\n<li>兼容性 <a href=\"http://kangax.github.io/compat-table/es6/\">对比表格</a></li>\n</ul>\n<h5 id=\"2、转码器\"><a href=\"#2、转码器\" class=\"headerlink\" title=\"2、转码器\"></a>2、转码器</h5><p>转码器可以将ES6代码转为ES5代码，常用的转码器：<a href=\"https://babeljs.io/\">babel转码器</a>、<br><a href=\"https://github.com/google/traceur-compiler\">Traceur转码器</a> 、 <a href=\"http://google.github.io/traceur-compiler/demo/repl.html\">Traceur在线转码</a></p>\n<h5 id=\"3、新特性\"><a href=\"#3、新特性\" class=\"headerlink\" title=\"3、新特性\"></a>3、新特性</h5><ul>\n<li>let and const命令</li>\n<li>Arrow Function箭头函数</li>\n<li>Destructuring Assignment （解构赋值）</li>\n<li>Generator函数</li>\n<li>Class</li>\n<li>Module</li>\n<li>Promise</li>\n</ul>\n<p>更多可参考<a href=\"http://es6-features.org/#Constants\">es6-features</a></p>\n<h4 id=\"二、Generator函数\"><a href=\"#二、Generator函数\" class=\"headerlink\" title=\"二、Generator函数\"></a>二、Generator函数</h4><p>在讲Generator之前，我们来说一下我们可能会遇到的这种场景：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 第1个ajax请求</div><div class=\"line\">$.ajax(&#123;</div><div class=\"line\">    url: &apos;/bankend/xxx/xxx&apos;,</div><div class=\"line\">    dateType:&apos;json&apos;,</div><div class=\"line\">    type:&apos;get&apos;,</div><div class=\"line\">    data:&#123;</div><div class=\"line\">        data:JSON.stringify(&#123;status:1,data:&apos;hello world&apos;&#125;),</div><div class=\"line\">        type:&apos;json&apos;,</div><div class=\"line\">        timeout:1000</div><div class=\"line\">    &#125;,</div><div class=\"line\">    success:function(data)&#123;</div><div class=\"line\">        if(data.status === 1)&#123;</div><div class=\"line\">            // 第2个ajax请求</div><div class=\"line\">            $.ajax(&#123;</div><div class=\"line\">                ......此处省略500字</div><div class=\"line\">                success:function(data)&#123;</div><div class=\"line\">                    if(data.status === 1)&#123;</div><div class=\"line\">                        // 第3个ajax请求</div><div class=\"line\">                        $.ajax(&#123;</div><div class=\"line\">                            ......此处省略500字</div><div class=\"line\">                            success:function(data)&#123;</div><div class=\"line\">                                if(data.status === 1)&#123;</div><div class=\"line\"></div><div class=\"line\">                                &#125;</div><div class=\"line\">                            &#125;</div><div class=\"line\">                        &#125;);</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>如果改用generator函数实现方式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">yield $.ajax(...); //第一个ajax请求</div><div class=\"line\">yield $.ajax(...); //第二个ajax请求</div><div class=\"line\">yield $.ajax(...); //第三个ajax请求</div><div class=\"line\">......   //第n个请求</div></pre></td></tr></table></figure>\n<p>这样的代码是不是让人看着更舒服一些。generator是如果实现的呢。首先我们得先了解一下generator的基本用法。</p>\n<h5 id=\"1、基本语法\"><a href=\"#1、基本语法\" class=\"headerlink\" title=\"1、基本语法\"></a>1、基本语法</h5><p>Generator函数是ES6中的一种异步实现函数，它类似一种状态机，通过yield产生各种状态，通过next方法执行各种状态。</p>\n<p>基本语法如下:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">//声明Generator函数</div><div class=\"line\">function* gen() &#123;</div><div class=\"line\">    yield 1;</div><div class=\"line\">    yield 2;</div><div class=\"line\">    yield 3;</div><div class=\"line\">    yield 4;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">//调用</div><div class=\"line\">var  g = gen();</div><div class=\"line\">g.next(); // &#123;value: 1, done: false&#125;</div><div class=\"line\">g.next(); // &#123;value: 2, done: false&#125;</div><div class=\"line\">g.next(); // &#123;value: 3, done: false&#125;</div><div class=\"line\">g.next(); // &#123;value: 4, done: false&#125;</div><div class=\"line\">g.next();  // &#123;value: undefined, done: true&#125;</div><div class=\"line\">g.next(); //&#123;value: undefined, done: true&#125;</div></pre></td></tr></table></figure>\n<p>调用generator函数返回的是一个指向内部状态的指针对象，即遍历器对象;通过返回的遍历器对象的next方法，使得指针指向下一个状态。每次调用next方法时，内部指针就从函数头或上一次停下来的地方开始执行，直到遇到下一个状态（下一条yield语句或return语句）为止。</p>\n<p>如下图所示：</p>\n<p><img src=\"http://haitao.nos.netease.com/6ad3f9d783c244d59dc785bbde15e4bd.png\" alt=\"image\"></p>\n<p><a href=\"http://people.mozilla.org/~jorendorff/demos/meow.html\">Demo</a></p>\n<h5 id=\"2、next方法参数、yield-语句\"><a href=\"#2、next方法参数、yield-语句\" class=\"headerlink\" title=\"2、next方法参数、yield*语句\"></a>2、next方法参数、yield*语句</h5><h6 id=\"（1）-next方法参数\"><a href=\"#（1）-next方法参数\" class=\"headerlink\" title=\"（1）. next方法参数\"></a>（1）. next方法参数</h6><p>yield语句本身没有返回值，或者说总是返回undefined。next方法可以带一个参数，该参数会被当作上一条yield语句的返回值。不明白啥意思，来个栗子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">function add(num1, num2) &#123;</div><div class=\"line\">    return num1 + num2;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">function* gen() &#123;</div><div class=\"line\">    var sum = add(yield 1, yield 3);</div><div class=\"line\">    return sum;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">var g = gen();</div><div class=\"line\">g.next(); //&#123; value: 1, done: false &#125;</div><div class=\"line\">g.next(); //&#123; value: 3, done: false &#125;</div><div class=\"line\">g.next(); //&#123; value: NaN, done: true &#125;</div><div class=\"line\">g.next(); //&#123; value: undefined, done: true &#125;</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">var g = gen();</div><div class=\"line\">g.next(); //&#123; value: 1, done: false &#125;</div><div class=\"line\">g.next(2); //&#123; value: 3, done: false &#125;</div><div class=\"line\">g.next(4); //&#123; value: 6, done: true &#125;</div><div class=\"line\">g.next(); //&#123; value: undefined, done: true &#125;</div></pre></td></tr></table></figure>\n<h6 id=\"（2）-yield-语句\"><a href=\"#（2）-yield-语句\" class=\"headerlink\" title=\"（2）. yield*语句\"></a>（2）. yield*语句</h6><p>如果在Generator函数内部调用另外一个Generator函数，需要yield*语句。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">function* innerGen() &#123;</div><div class=\"line\">    yield 2;</div><div class=\"line\">    yield 3;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">function* outGen() &#123;</div><div class=\"line\">    yield 1;</div><div class=\"line\">    innerGen();</div><div class=\"line\">    yield 4;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">function* outGenYield() &#123;</div><div class=\"line\">    yield 1;</div><div class=\"line\">    yield* innerGen();</div><div class=\"line\">    yield 4;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">var g = outGen();</div><div class=\"line\">g.next(); //&#123; value: 1, done: false &#125;</div><div class=\"line\">g.next(); //&#123; value: 4, done: false &#125;</div><div class=\"line\">g.next(); //&#123; value: undefined, done: true &#125;</div><div class=\"line\">g.next(); //&#123; value: undefined, done: true &#125;</div><div class=\"line\">g.next(); //&#123; value: undefined, done: true &#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">var outgen = outGenYield();</div><div class=\"line\">outgen.next(); //&#123; value: 1, done: false &#125;</div><div class=\"line\">outgen.next(); //&#123; value: 2, done: false &#125;</div><div class=\"line\">outgen.next(); //&#123; value: 3, done: false &#125;</div><div class=\"line\">outgen.next(); //&#123; value: 4, done: false &#125;</div><div class=\"line\">outgen.next(); //&#123; value: undefined, done: true &#125;</div></pre></td></tr></table></figure>\n<p>使用yield*语句，generator函数的状态变化如下图所示：<br><img src=\"http://haitao.nos.netease.com/a2d7daf768ca48ceb17eec9af02816e3.png\" alt=\"图2\"></p>\n<p>看下面例子输出什么：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">function* gen() &#123;</div><div class=\"line\">    for (let i=0; i &lt; 5; i++) &#123;</div><div class=\"line\">        console.log(i);</div><div class=\"line\">        let temp = yield i;</div><div class=\"line\">        console.log(i);</div><div class=\"line\">        console.log(temp);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">var g = gen();</div><div class=\"line\">console.log(g.next()); // ?</div><div class=\"line\">console.log(g.next()); //?</div><div class=\"line\">console.log(g.next()); // ?</div><div class=\"line\">console.log(g.next()); // ?</div><div class=\"line\">console.log(g.next()); // ?</div><div class=\"line\">console.log(g.next()); // ?</div><div class=\"line\"></div><div class=\"line\">//输出结果？</div></pre></td></tr></table></figure>\n<h5 id=\"3、for…of循环、throw、return方法\"><a href=\"#3、for…of循环、throw、return方法\" class=\"headerlink\" title=\"3、for…of循环、throw、return方法\"></a>3、for…of循环、throw、return方法</h5><h6 id=\"（1）-for…of循环\"><a href=\"#（1）-for…of循环\" class=\"headerlink\" title=\"（1）. for…of循环\"></a>（1）. for…of循环</h6><p>for…of循环可以自动遍历Generator函数，不需要再使用next方法。for…of只循环Generator的每个状态，不包含开始和结束节点。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\">function* gen() &#123;</div><div class=\"line\">    console.log(&quot;front 1&quot;);</div><div class=\"line\">    yield 1;</div><div class=\"line\">    console.log(&quot;front 2&quot;);</div><div class=\"line\">    yield 2;</div><div class=\"line\">    console.log(&quot;front 3&quot;);</div><div class=\"line\">    yield 3;</div><div class=\"line\">    console.log(&quot;front 4&quot;);</div><div class=\"line\">    yield 4;</div><div class=\"line\">    console.log(&quot;front 5&quot;);</div><div class=\"line\">    return 5;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">for (let v of gen()) &#123;</div><div class=\"line\">    console.log(v);</div><div class=\"line\">&#125;</div><div class=\"line\">// 结果</div><div class=\"line\">front 1</div><div class=\"line\">1</div><div class=\"line\">front 2</div><div class=\"line\">2</div><div class=\"line\">front 3</div><div class=\"line\">3</div><div class=\"line\">front 4</div><div class=\"line\">4</div><div class=\"line\">front 5</div></pre></td></tr></table></figure>\n<h6 id=\"（2）-throw方法\"><a href=\"#（2）-throw方法\" class=\"headerlink\" title=\"（2）. throw方法\"></a>（2）. throw方法</h6><p>Generator函数返回的遍历器对象都有一个throw方法， Generator.prototype.throw(),可以在函数体外抛出错误，然后在Generator函数体内捕获。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">var g = function* () &#123;</div><div class=\"line\">  try &#123;</div><div class=\"line\">    yield;</div><div class=\"line\">  &#125; catch (e) &#123;</div><div class=\"line\">    console.log(&apos;内部捕获&apos;, e);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">var i = g();</div><div class=\"line\">i.next();</div><div class=\"line\"></div><div class=\"line\">try &#123;</div><div class=\"line\">  i.throw(&apos;a&apos;);</div><div class=\"line\">  i.throw(&apos;b&apos;);</div><div class=\"line\">&#125; catch (e) &#123;</div><div class=\"line\">  console.log(&apos;外部捕获&apos;, e);</div><div class=\"line\">&#125;</div><div class=\"line\">// 内部捕获 a</div><div class=\"line\">// 外部捕获 b</div></pre></td></tr></table></figure>\n<h6 id=\"（3）-return方法\"><a href=\"#（3）-return方法\" class=\"headerlink\" title=\"（3）. return方法\"></a>（3）. return方法</h6><p>Generator函数返回的遍历器对象还有一个return方法，返回给定的值，并终结Generator函数的遍历。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">function* gen() &#123;</div><div class=\"line\">    yield 1;</div><div class=\"line\">    yield 2;</div><div class=\"line\">    yield 3;</div><div class=\"line\">    return 4;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">var g = gen();</div><div class=\"line\">g.next();  // &#123;value: 1, done: false&#125;</div><div class=\"line\">g.return(6); //&#123;value: 6, done: true&#125;</div><div class=\"line\">g.next();   //&#123;valude: undefined, done: true&#125;</div></pre></td></tr></table></figure></p>\n<h4 id=\"三、-应用\"><a href=\"#三、-应用\" class=\"headerlink\" title=\"三、 应用\"></a>三、 应用</h4><h5 id=\"1-Generator实现异步\"><a href=\"#1-Generator实现异步\" class=\"headerlink\" title=\"1. Generator实现异步\"></a>1. Generator实现异步</h5><p>Generator函数可以暂停执行和恢复执行，这是它能封装异步任务的根本原因。</p>\n<p>来看一下开始的例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">function* gen()&#123;</div><div class=\"line\">  yield $.ajax(...); //第一个ajax请求</div><div class=\"line\">  yield $.ajax(...); //第二个ajax请求</div><div class=\"line\">  yield $.ajax(...); //第三个ajax请求</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>如果写成这样子我们改如何让请求一个个完成或再执行下一个请求呢。</p>\n<p><strong>思路：</strong><br>当完成一个请求，我们再调用下一个next()执行下一个状态即下一个请求。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">function next(err, data) &#123;</div><div class=\"line\">    var result = gen.next(data);</div><div class=\"line\">    if (result.done) return;</div><div class=\"line\">    result.value.then(function()&#123;</div><div class=\"line\">        next();</div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;</div><div class=\"line\">next();</div></pre></td></tr></table></figure>\n<p><img src=\"http://haitao.nos.netease.com/8ec00addae2343d7871dcf23a1c58254.png\" alt=\"image\"></p>\n<p>co就是上面那个自动执行器的扩展。<a href=\"https://github.com/tj/co\">co模块源码</a><br>用法:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">co(function* () &#123;</div><div class=\"line\">  var result = yield Promise.resolve(true);</div><div class=\"line\">  return result;</div><div class=\"line\">&#125;).then(function (value) &#123;</div><div class=\"line\">  console.log(value);</div><div class=\"line\">&#125;, function (err) &#123;</div><div class=\"line\">  console.error(err.stack);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<h5 id=\"2-koa框架\"><a href=\"#2-koa框架\" class=\"headerlink\" title=\"2. koa框架\"></a>2. koa框架</h5><p><a href=\"http://koa.rednode.cn/\">koa</a>是由Express是Express原班人马打造的一个更小，基于nodejs平台的下一代web开发框架。Koa的精妙之处就在于其使用generator，实现了一种更为有趣的中间件系统，Koa的中间件是一系列generator函数的对象，执行起来有点类似于栈的结构，依次执行。</p>\n<p>当一个请求过来的时候，会依次经过各个中间件进行处理，中间件跳转的信号是yield next，当到某个中间件后，该中间件处理完不执行yield next的时候，然后就会逆序执行前面那些中间件剩下的逻辑。、</p>\n<p>总体架构图：</p>\n<p><img src=\"http://haitao.nos.netease.com/916ebdb8f2db4d05a47f3d35c4b6d3a4.png\" alt=\"image\"></p>\n<p>内部实现图：<br><img src=\"http://haitao.nos.netease.com/f2044faa49d944ed91c05d4264e766ef.png\" alt=\"image\"></p>\n<p>直接上个官网的例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\">var koa = require(&apos;koa&apos;);</div><div class=\"line\">var app = koa();</div><div class=\"line\"></div><div class=\"line\">// response-time中间件</div><div class=\"line\">app.use(function *(next)&#123;</div><div class=\"line\">  var start = new Date;</div><div class=\"line\">  yield next;</div><div class=\"line\">  var ms = new Date - start;</div><div class=\"line\">  this.set(&apos;X-Response-Time&apos;, ms + &apos;ms&apos;);</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">// logger中间件</div><div class=\"line\">app.use(function *(next)&#123;</div><div class=\"line\">  var start = new Date;</div><div class=\"line\">  yield next;</div><div class=\"line\">  var ms = new Date - start;</div><div class=\"line\">  console.log(&apos;%s %s - %s&apos;, this.method, this.url, ms);</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">// 响应中间件</div><div class=\"line\">app.use(function *()&#123;</div><div class=\"line\">  this.body = &apos;Hello World&apos;;</div><div class=\"line\">&#125;);</div><div class=\"line\">app.listen(3000);</div></pre></td></tr></table></figure>\n<p>上面的执行顺序就是：</p>\n<p>请求 ==&gt; response-time中间件 ==&gt; logger中间件 ==&gt; 响应中间件 ==&gt; logger中间件 ==&gt; response-time中间件 ==&gt; 响应。</p>\n<p>更详细描述就是：请求进来，先进到response-time中间件，执行 var start = new Date; 然后遇到yield next，则暂停response-time中间件的执行，跳转进logger中间件，同理，最后进入响应中间件，响应中间件中没有yield next代码，则开始逆序执行，也就是再先是回到logger中间件，执行yield next之后的代码，执行完后再回到response-time中间件执行yield next之后的代码。</p>\n<p>koa中间的实现原理：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div></pre></td><td class=\"code\"><pre><div class=\"line\">app.use = function(fn)&#123;</div><div class=\"line\">  if (!this.experimental) &#123;</div><div class=\"line\">    // es7 async functions are not allowed,</div><div class=\"line\">    // so we have to make sure that `fn` is a generator function</div><div class=\"line\">    assert(fn &amp;&amp; &apos;GeneratorFunction&apos; == fn.constructor.name, &apos;app.use() requires a generator function&apos;);</div><div class=\"line\">  &#125;</div><div class=\"line\">  debug(&apos;use %s&apos;, fn._name || fn.name || &apos;-&apos;);</div><div class=\"line\">  this.middleware.push(fn);</div><div class=\"line\">  return this;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">app.callback = function()&#123;</div><div class=\"line\">  if (this.experimental) &#123;</div><div class=\"line\">    console.error(&apos;Experimental ES7 Async Function support is deprecated. Please look into Koa v2 as the middleware signature has changed.&apos;)</div><div class=\"line\">  &#125;</div><div class=\"line\">  var fn = this.experimental</div><div class=\"line\">    ? compose_es7(this.middleware)</div><div class=\"line\">    : co.wrap(compose(this.middleware));</div><div class=\"line\">  var self = this;</div><div class=\"line\"></div><div class=\"line\">  if (!this.listeners(&apos;error&apos;).length) this.on(&apos;error&apos;, this.onerror);</div><div class=\"line\"></div><div class=\"line\">  return function(req, res)&#123;</div><div class=\"line\">    res.statusCode = 404;</div><div class=\"line\">    var ctx = self.createContext(req, res);</div><div class=\"line\">    onFinished(res, ctx.onerror);</div><div class=\"line\">    fn.call(ctx).then(function () &#123;</div><div class=\"line\">      respond.call(ctx);</div><div class=\"line\">    &#125;).catch(ctx.onerror);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">function compose(middleware)&#123;</div><div class=\"line\">  return function *(next)&#123;</div><div class=\"line\">    if (!next) next = noop();</div><div class=\"line\"></div><div class=\"line\">    var i = middleware.length;</div><div class=\"line\"></div><div class=\"line\">    while (i--) &#123;</div><div class=\"line\">      next = middleware[i].call(this, next);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    return yield *next;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">/**</div><div class=\"line\"> * Noop.</div><div class=\"line\"> *</div><div class=\"line\"> * @api private</div><div class=\"line\"> */</div><div class=\"line\"></div><div class=\"line\">function *noop()&#123;&#125;</div></pre></td></tr></table></figure>\n<p>参考文章：</p>\n<p><a href=\"https://github.com/alsotang/node-lessons/tree/master/lesson18\">原生httpServer、<br>connect、express简单介绍</a></p>\n<p><a href=\"https://github.com/koajs/koa\">koa源码</a></p>\n"},{"title":"Hexo + github 搭建自己的博客","date":"2016-04-09T15:11:09.000Z","_content":"## 1. 配置环境\n 安装node，在[node官网](http://nodejs.cn/)上下载node，进行安装\n\n 安装Git, 下载[Git](https://git-scm.com/download/)进行安装\n\n ## 2. 安装HEXO\n 安装hexo\n ``` bash\nnpm install  -g hexo -cli\n ```\n 进入你的blog目录，初始化配置\n ```bash\nhexo init <folder>\ncd blog\nnpm install\n ```\n启动本地服务, 再浏览器查看[http://localhost:4000/](http://localhost:4000/)\n```bash\nhexo server\n```\n## 3. 部署到github上\n生成静态资源\n```bash\nhexo generate\n```\n生成的静态资源在public目录下，把public的全部资源拷贝出来，push到gh-pages分支上\n\n## 4. 参考资料：\n1.[hexo官网](https://hexo.io/zh-cn/docs/)\n2.[concise主题](https://github.com/HmyBmny/hexo-theme-concise)\n3.[HEXO+Github,搭建属于自己的博客](http://www.jianshu.com/p/465830080ea9)\n","source":"_posts/createblog.md","raw":"---\ntitle: Hexo + github 搭建自己的博客\ndate: 2016-04-09 23:11:09\ntags: 技术\ncategories: 技术\n---\n## 1. 配置环境\n 安装node，在[node官网](http://nodejs.cn/)上下载node，进行安装\n\n 安装Git, 下载[Git](https://git-scm.com/download/)进行安装\n\n ## 2. 安装HEXO\n 安装hexo\n ``` bash\nnpm install  -g hexo -cli\n ```\n 进入你的blog目录，初始化配置\n ```bash\nhexo init <folder>\ncd blog\nnpm install\n ```\n启动本地服务, 再浏览器查看[http://localhost:4000/](http://localhost:4000/)\n```bash\nhexo server\n```\n## 3. 部署到github上\n生成静态资源\n```bash\nhexo generate\n```\n生成的静态资源在public目录下，把public的全部资源拷贝出来，push到gh-pages分支上\n\n## 4. 参考资料：\n1.[hexo官网](https://hexo.io/zh-cn/docs/)\n2.[concise主题](https://github.com/HmyBmny/hexo-theme-concise)\n3.[HEXO+Github,搭建属于自己的博客](http://www.jianshu.com/p/465830080ea9)\n","slug":"createblog","published":1,"updated":"2016-08-21T12:04:09.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cis4l3qtc00021hp47gca4spm","content":"<h2 id=\"1-配置环境\"><a href=\"#1-配置环境\" class=\"headerlink\" title=\"1. 配置环境\"></a>1. 配置环境</h2><p> 安装node，在<a href=\"http://nodejs.cn/\" target=\"_blank\" rel=\"external\">node官网</a>上下载node，进行安装</p>\n<p> 安装Git, 下载<a href=\"https://git-scm.com/download/\" target=\"_blank\" rel=\"external\">Git</a>进行安装</p>\n<h2 id=\"2-安装HEXO\"><a href=\"#2-安装HEXO\" class=\"headerlink\" title=\"2. 安装HEXO\"></a>2. 安装HEXO</h2><p> 安装hexo<br> <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">npm install  -g hexo -cli</div></pre></td></tr></table></figure></p>\n<p> 进入你的blog目录，初始化配置<br> <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">hexo init &lt;folder&gt;</div><div class=\"line\"><span class=\"built_in\">cd</span> blog</div><div class=\"line\">npm install</div></pre></td></tr></table></figure></p>\n<p>启动本地服务, 再浏览器查看<a href=\"http://localhost:4000/\" target=\"_blank\" rel=\"external\">http://localhost:4000/</a><br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">hexo server</div></pre></td></tr></table></figure></p>\n<h2 id=\"3-部署到github上\"><a href=\"#3-部署到github上\" class=\"headerlink\" title=\"3. 部署到github上\"></a>3. 部署到github上</h2><p>生成静态资源<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">hexo generate</div></pre></td></tr></table></figure></p>\n<p>生成的静态资源在public目录下，把public的全部资源拷贝出来，push到gh-pages分支上</p>\n<h2 id=\"4-参考资料：\"><a href=\"#4-参考资料：\" class=\"headerlink\" title=\"4. 参考资料：\"></a>4. 参考资料：</h2><p>1.<a href=\"https://hexo.io/zh-cn/docs/\" target=\"_blank\" rel=\"external\">hexo官网</a><br>2.<a href=\"https://github.com/HmyBmny/hexo-theme-concise\" target=\"_blank\" rel=\"external\">concise主题</a><br>3.<a href=\"http://www.jianshu.com/p/465830080ea9\" target=\"_blank\" rel=\"external\">HEXO+Github,搭建属于自己的博客</a></p>\n","excerpt":"","more":"<h2 id=\"1-配置环境\"><a href=\"#1-配置环境\" class=\"headerlink\" title=\"1. 配置环境\"></a>1. 配置环境</h2><p> 安装node，在<a href=\"http://nodejs.cn/\">node官网</a>上下载node，进行安装</p>\n<p> 安装Git, 下载<a href=\"https://git-scm.com/download/\">Git</a>进行安装</p>\n<h2 id=\"2-安装HEXO\"><a href=\"#2-安装HEXO\" class=\"headerlink\" title=\"2. 安装HEXO\"></a>2. 安装HEXO</h2><p> 安装hexo<br> <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">npm install  -g hexo -cli</div></pre></td></tr></table></figure></p>\n<p> 进入你的blog目录，初始化配置<br> <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">hexo init &lt;folder&gt;</div><div class=\"line\"><span class=\"built_in\">cd</span> blog</div><div class=\"line\">npm install</div></pre></td></tr></table></figure></p>\n<p>启动本地服务, 再浏览器查看<a href=\"http://localhost:4000/\">http://localhost:4000/</a><br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">hexo server</div></pre></td></tr></table></figure></p>\n<h2 id=\"3-部署到github上\"><a href=\"#3-部署到github上\" class=\"headerlink\" title=\"3. 部署到github上\"></a>3. 部署到github上</h2><p>生成静态资源<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">hexo generate</div></pre></td></tr></table></figure></p>\n<p>生成的静态资源在public目录下，把public的全部资源拷贝出来，push到gh-pages分支上</p>\n<h2 id=\"4-参考资料：\"><a href=\"#4-参考资料：\" class=\"headerlink\" title=\"4. 参考资料：\"></a>4. 参考资料：</h2><p>1.<a href=\"https://hexo.io/zh-cn/docs/\">hexo官网</a><br>2.<a href=\"https://github.com/HmyBmny/hexo-theme-concise\">concise主题</a><br>3.<a href=\"http://www.jianshu.com/p/465830080ea9\">HEXO+Github,搭建属于自己的博客</a></p>\n"},{"title":"reactJS中问题整理","date":"2016-06-21T12:13:59.000Z","_content":"\n##### Q: reactjs为什么要设计成单向数据流？\n**A**：\"在React中，数据流向是单向的——从父节点传递到子节点，因而组件是简单且易于把握的，他们只需从父节点获取props渲染即可。如果顶层组件的某个prop改变了，React会递归地向下遍历整棵组建树，重新渲染所有使用这个属性的组件。\"\n\n个人觉得这个解释不是很全面，搜到一个相关文章[React 单向数据流分析](http://karynsong.github.io/2016-02/38/)，但是讲得也不是很清楚， 我觉得可以看完Redux再回过来总结这个问题。\n\n\n##### Q. 外部传入的props与getDefaultProps的关系，是谁覆盖谁？\n**A:** 外部传入的props与getDefaultProps的关系是外部传入的props属性覆盖getDefaultProps。\n\n```\nvar Hello = React.createClass({\n  render: function() {\n    return <ChildNode name=\"parentNode\" />;\n  }\n});\nvar ChildNode = React.createClass({\n getDefaultProps: function() {\n  \treturn {name: 'childNode'};\n  },\n  render: function() {\n    return <div>Hello {this.props.name}</div>;\n  }\n});\n\nReactDOM.render(\n  <Hello />,\n  document.getElementById('container')\n);\n\n\n//输出\nHello parentNode\n```\n\n\n\n##### Q. 生命周期的componentDidMount时期是否已经插入了DOM？\n**A:** componentDidMount时期已经插入了DOM，\n\n```\nvar Hello = React.createClass({\n  render: function() {\n    return <ChildNode name=\"parentNode\" />;\n  }\n});\nvar ChildNode = React.createClass({\n\tgetDefaultProps: function() {\n  \tconsole.log(123);\n  \treturn {name: 'childNode'};\n  },\n  componentDidMount: function() {\n  \tvar childNode = document.getElementById('childId');\n    console.log(childNode);\n  },\n  render: function() {\n    return <div id=\"childId\">Hello {this.props.name}</div>;\n  }\n});\n\nReactDOM.render(\n  <Hello />,\n  document.getElementById('container')\n);\n```\n\n控制台输出:\n\n```\n<div data-reactroot=\"\" id=\"childId\">\n<!-- react-text: 2 -->\nHello \n<!-- /react-text -->\n<!-- react-text: 3 -->\nparentNode\n<!-- /react-text -->\n</div>\n```\n\n##### 4. componentWillReceiveProps的作用， 会继续执行render吗？\n**A:**   在组件接收到新的 props 的时候调用。在初始化渲染的时候，该方法不会调用。\n用此函数可以作为 react 在 prop 传入之后， render() 渲染之前更新 state 的机会。老的 props 可以通过 this.props 获取到。在该函数中调用 this.setState() 将不会引起第二次渲染。\n\n```\nvar Hello = React.createClass({\n    getInitialState: function () {\n        return {name: 'parentNode'};\n    },\n    clickBtn: function () {\n        this.setState({name: 'change ParentNode!'});\n    },\n    render: function () {\n        return <div className={this.state.name}>\n            <ChildNode name=\"parentNode\"/>;\n            <button onClick={this.clickBtn}>点击</button>\n        </div>\n    }\n});\nvar ChildNode = React.createClass({\n    getDefaultProps: function () {\n        return {name: 'childNode'};\n    },\n    getInitialState: function () {\n        return {message: 'welcome!'};\n    },\n    componentDidMount: function () {\n        var childNode = document.getElementById('childId');\n    },\n    componentWillReceiveProps: function (nextProps) {\n        console.log('componentWillReceiveProps---'+nextProps.name);\n        console.log('componentWillReceiveProps---'+ this.props.name);\n        console.log('componentWillReceiveProps---'+this.state.message);\n        this.setState({message: 'change Welcome'});\n\n    },\n    render: function () {\n        console.log('render---' + this.state.message);\n        return <div id=\"childId\">Hello {this.props.name} {this.state.message}</div>;\n    }\n});\n\nReactDOM.render(\n    <Hello />,\n    document.getElementById('container')\n);\n\n```\n初始运行时：\n\n```\n页面输出：\nHello parentNode welcome!\n\n制台输出:\nrender---welcome!\n```\n点击btn的是时：\n\n```\n页面值：\nHello parentNode change Welcome\n\n控制台输出:\ncomponentWillReceiveProps---parentNode\ncomponentWillReceiveProps---parentNode\ncomponentWillReceiveProps---welcome!\nrender---change Welcome\n```\n\n**官网总结：**\n\n当节点初次被放入的时候 componentWillReceiveProps 并不会被触发。这是故意这么设计的？\n\n原因是因为 componentWillReceiveProps 经常会处理一些和 old props 比较的逻辑，而且会在变化之前执行；不在组件即将渲染的时候触发，这也是这个方法设计的初衷。\n\n##### 5. immutableJS是如何解决shouldComponentUpdate中复杂对象的比较的？\n**A:**  \n在shouldComponentUpdate分别判断props和state有没有变化。\n\nshouldComponentUpdate中使用immutableJS代码：\n```\nimport { is } from 'immutable';\n\nshouldComponentUpdate: (nextProps = {}, nextState = {}) => {\n  const thisProps = this.props || {}, thisState = this.state || {};\n\n  if (Object.keys(thisProps).length !== Object.keys(nextProps).length ||\n      Object.keys(thisState).length !== Object.keys(nextState).length) {\n    return true;\n  }\n\n  for (const key in nextProps) {\n    if (thisProps[key] !== nextProps[key] || is(thisProps[key], nextProps[key])) {\n      return true;\n    }\n  }\n\n  for (const key in nextState) {\n    if (thisState[key] !== nextState[key] || is(thisState[key], nextState[key])) {\n      return true;\n    }\n  }\n  return false;\n}\n```\nis方法是先比较两个对象是不是同一个地址， 再比较两个对象的valueOf，即两个对象的值上否相同。\nimmutableJS中is实现代码：\n```\nexport function is(valueA, valueB) {\n  if (valueA === valueB || (valueA !== valueA && valueB !== valueB)) {\n    return true;\n  }\n  if (!valueA || !valueB) {\n    return false;\n  }\n  if (typeof valueA.valueOf === 'function' &&\n      typeof valueB.valueOf === 'function') {\n    valueA = valueA.valueOf();\n    valueB = valueB.valueOf();\n    if (valueA === valueB || (valueA !== valueA && valueB !== valueB)) {\n      return true;\n    }\n    if (!valueA || !valueB) {\n      return false;\n    }\n  }\n  if (typeof valueA.equals === 'function' &&\n      typeof valueB.equals === 'function' &&\n      valueA.equals(valueB)) {\n    return true;\n  }\n  return false;\n}\n```\n\n\n","source":"_posts/react-question.md","raw":"---\ntitle: reactJS中问题整理\ndate: 2016-06-21 20:13:59\ntags: ReactJS\ncategories: React\n---\n\n##### Q: reactjs为什么要设计成单向数据流？\n**A**：\"在React中，数据流向是单向的——从父节点传递到子节点，因而组件是简单且易于把握的，他们只需从父节点获取props渲染即可。如果顶层组件的某个prop改变了，React会递归地向下遍历整棵组建树，重新渲染所有使用这个属性的组件。\"\n\n个人觉得这个解释不是很全面，搜到一个相关文章[React 单向数据流分析](http://karynsong.github.io/2016-02/38/)，但是讲得也不是很清楚， 我觉得可以看完Redux再回过来总结这个问题。\n\n\n##### Q. 外部传入的props与getDefaultProps的关系，是谁覆盖谁？\n**A:** 外部传入的props与getDefaultProps的关系是外部传入的props属性覆盖getDefaultProps。\n\n```\nvar Hello = React.createClass({\n  render: function() {\n    return <ChildNode name=\"parentNode\" />;\n  }\n});\nvar ChildNode = React.createClass({\n getDefaultProps: function() {\n  \treturn {name: 'childNode'};\n  },\n  render: function() {\n    return <div>Hello {this.props.name}</div>;\n  }\n});\n\nReactDOM.render(\n  <Hello />,\n  document.getElementById('container')\n);\n\n\n//输出\nHello parentNode\n```\n\n\n\n##### Q. 生命周期的componentDidMount时期是否已经插入了DOM？\n**A:** componentDidMount时期已经插入了DOM，\n\n```\nvar Hello = React.createClass({\n  render: function() {\n    return <ChildNode name=\"parentNode\" />;\n  }\n});\nvar ChildNode = React.createClass({\n\tgetDefaultProps: function() {\n  \tconsole.log(123);\n  \treturn {name: 'childNode'};\n  },\n  componentDidMount: function() {\n  \tvar childNode = document.getElementById('childId');\n    console.log(childNode);\n  },\n  render: function() {\n    return <div id=\"childId\">Hello {this.props.name}</div>;\n  }\n});\n\nReactDOM.render(\n  <Hello />,\n  document.getElementById('container')\n);\n```\n\n控制台输出:\n\n```\n<div data-reactroot=\"\" id=\"childId\">\n<!-- react-text: 2 -->\nHello \n<!-- /react-text -->\n<!-- react-text: 3 -->\nparentNode\n<!-- /react-text -->\n</div>\n```\n\n##### 4. componentWillReceiveProps的作用， 会继续执行render吗？\n**A:**   在组件接收到新的 props 的时候调用。在初始化渲染的时候，该方法不会调用。\n用此函数可以作为 react 在 prop 传入之后， render() 渲染之前更新 state 的机会。老的 props 可以通过 this.props 获取到。在该函数中调用 this.setState() 将不会引起第二次渲染。\n\n```\nvar Hello = React.createClass({\n    getInitialState: function () {\n        return {name: 'parentNode'};\n    },\n    clickBtn: function () {\n        this.setState({name: 'change ParentNode!'});\n    },\n    render: function () {\n        return <div className={this.state.name}>\n            <ChildNode name=\"parentNode\"/>;\n            <button onClick={this.clickBtn}>点击</button>\n        </div>\n    }\n});\nvar ChildNode = React.createClass({\n    getDefaultProps: function () {\n        return {name: 'childNode'};\n    },\n    getInitialState: function () {\n        return {message: 'welcome!'};\n    },\n    componentDidMount: function () {\n        var childNode = document.getElementById('childId');\n    },\n    componentWillReceiveProps: function (nextProps) {\n        console.log('componentWillReceiveProps---'+nextProps.name);\n        console.log('componentWillReceiveProps---'+ this.props.name);\n        console.log('componentWillReceiveProps---'+this.state.message);\n        this.setState({message: 'change Welcome'});\n\n    },\n    render: function () {\n        console.log('render---' + this.state.message);\n        return <div id=\"childId\">Hello {this.props.name} {this.state.message}</div>;\n    }\n});\n\nReactDOM.render(\n    <Hello />,\n    document.getElementById('container')\n);\n\n```\n初始运行时：\n\n```\n页面输出：\nHello parentNode welcome!\n\n制台输出:\nrender---welcome!\n```\n点击btn的是时：\n\n```\n页面值：\nHello parentNode change Welcome\n\n控制台输出:\ncomponentWillReceiveProps---parentNode\ncomponentWillReceiveProps---parentNode\ncomponentWillReceiveProps---welcome!\nrender---change Welcome\n```\n\n**官网总结：**\n\n当节点初次被放入的时候 componentWillReceiveProps 并不会被触发。这是故意这么设计的？\n\n原因是因为 componentWillReceiveProps 经常会处理一些和 old props 比较的逻辑，而且会在变化之前执行；不在组件即将渲染的时候触发，这也是这个方法设计的初衷。\n\n##### 5. immutableJS是如何解决shouldComponentUpdate中复杂对象的比较的？\n**A:**  \n在shouldComponentUpdate分别判断props和state有没有变化。\n\nshouldComponentUpdate中使用immutableJS代码：\n```\nimport { is } from 'immutable';\n\nshouldComponentUpdate: (nextProps = {}, nextState = {}) => {\n  const thisProps = this.props || {}, thisState = this.state || {};\n\n  if (Object.keys(thisProps).length !== Object.keys(nextProps).length ||\n      Object.keys(thisState).length !== Object.keys(nextState).length) {\n    return true;\n  }\n\n  for (const key in nextProps) {\n    if (thisProps[key] !== nextProps[key] || is(thisProps[key], nextProps[key])) {\n      return true;\n    }\n  }\n\n  for (const key in nextState) {\n    if (thisState[key] !== nextState[key] || is(thisState[key], nextState[key])) {\n      return true;\n    }\n  }\n  return false;\n}\n```\nis方法是先比较两个对象是不是同一个地址， 再比较两个对象的valueOf，即两个对象的值上否相同。\nimmutableJS中is实现代码：\n```\nexport function is(valueA, valueB) {\n  if (valueA === valueB || (valueA !== valueA && valueB !== valueB)) {\n    return true;\n  }\n  if (!valueA || !valueB) {\n    return false;\n  }\n  if (typeof valueA.valueOf === 'function' &&\n      typeof valueB.valueOf === 'function') {\n    valueA = valueA.valueOf();\n    valueB = valueB.valueOf();\n    if (valueA === valueB || (valueA !== valueA && valueB !== valueB)) {\n      return true;\n    }\n    if (!valueA || !valueB) {\n      return false;\n    }\n  }\n  if (typeof valueA.equals === 'function' &&\n      typeof valueB.equals === 'function' &&\n      valueA.equals(valueB)) {\n    return true;\n  }\n  return false;\n}\n```\n\n\n","slug":"react-question","published":1,"updated":"2016-08-21T12:15:56.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cis4l3qtu00061hp46gprhero","content":"<h5 id=\"Q-reactjs为什么要设计成单向数据流？\"><a href=\"#Q-reactjs为什么要设计成单向数据流？\" class=\"headerlink\" title=\"Q: reactjs为什么要设计成单向数据流？\"></a>Q: reactjs为什么要设计成单向数据流？</h5><p><strong>A</strong>：”在React中，数据流向是单向的——从父节点传递到子节点，因而组件是简单且易于把握的，他们只需从父节点获取props渲染即可。如果顶层组件的某个prop改变了，React会递归地向下遍历整棵组建树，重新渲染所有使用这个属性的组件。”</p>\n<p>个人觉得这个解释不是很全面，搜到一个相关文章<a href=\"http://karynsong.github.io/2016-02/38/\" target=\"_blank\" rel=\"external\">React 单向数据流分析</a>，但是讲得也不是很清楚， 我觉得可以看完Redux再回过来总结这个问题。</p>\n<h5 id=\"Q-外部传入的props与getDefaultProps的关系，是谁覆盖谁？\"><a href=\"#Q-外部传入的props与getDefaultProps的关系，是谁覆盖谁？\" class=\"headerlink\" title=\"Q. 外部传入的props与getDefaultProps的关系，是谁覆盖谁？\"></a>Q. 外部传入的props与getDefaultProps的关系，是谁覆盖谁？</h5><p><strong>A:</strong> 外部传入的props与getDefaultProps的关系是外部传入的props属性覆盖getDefaultProps。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\">var Hello = React.createClass(&#123;</div><div class=\"line\">  render: function() &#123;</div><div class=\"line\">    return &lt;ChildNode name=&quot;parentNode&quot; /&gt;;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;);</div><div class=\"line\">var ChildNode = React.createClass(&#123;</div><div class=\"line\"> getDefaultProps: function() &#123;</div><div class=\"line\">  \treturn &#123;name: &apos;childNode&apos;&#125;;</div><div class=\"line\">  &#125;,</div><div class=\"line\">  render: function() &#123;</div><div class=\"line\">    return &lt;div&gt;Hello &#123;this.props.name&#125;&lt;/div&gt;;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">ReactDOM.render(</div><div class=\"line\">  &lt;Hello /&gt;,</div><div class=\"line\">  document.getElementById(&apos;container&apos;)</div><div class=\"line\">);</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">//输出</div><div class=\"line\">Hello parentNode</div></pre></td></tr></table></figure>\n<h5 id=\"Q-生命周期的componentDidMount时期是否已经插入了DOM？\"><a href=\"#Q-生命周期的componentDidMount时期是否已经插入了DOM？\" class=\"headerlink\" title=\"Q. 生命周期的componentDidMount时期是否已经插入了DOM？\"></a>Q. 生命周期的componentDidMount时期是否已经插入了DOM？</h5><p><strong>A:</strong> componentDidMount时期已经插入了DOM，</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\">var Hello = React.createClass(&#123;</div><div class=\"line\">  render: function() &#123;</div><div class=\"line\">    return &lt;ChildNode name=&quot;parentNode&quot; /&gt;;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;);</div><div class=\"line\">var ChildNode = React.createClass(&#123;</div><div class=\"line\">\tgetDefaultProps: function() &#123;</div><div class=\"line\">  \tconsole.log(123);</div><div class=\"line\">  \treturn &#123;name: &apos;childNode&apos;&#125;;</div><div class=\"line\">  &#125;,</div><div class=\"line\">  componentDidMount: function() &#123;</div><div class=\"line\">  \tvar childNode = document.getElementById(&apos;childId&apos;);</div><div class=\"line\">    console.log(childNode);</div><div class=\"line\">  &#125;,</div><div class=\"line\">  render: function() &#123;</div><div class=\"line\">    return &lt;div id=&quot;childId&quot;&gt;Hello &#123;this.props.name&#125;&lt;/div&gt;;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">ReactDOM.render(</div><div class=\"line\">  &lt;Hello /&gt;,</div><div class=\"line\">  document.getElementById(&apos;container&apos;)</div><div class=\"line\">);</div></pre></td></tr></table></figure>\n<p>控制台输出:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;div data-reactroot=&quot;&quot; id=&quot;childId&quot;&gt;</div><div class=\"line\">&lt;!-- react-text: 2 --&gt;</div><div class=\"line\">Hello </div><div class=\"line\">&lt;!-- /react-text --&gt;</div><div class=\"line\">&lt;!-- react-text: 3 --&gt;</div><div class=\"line\">parentNode</div><div class=\"line\">&lt;!-- /react-text --&gt;</div><div class=\"line\">&lt;/div&gt;</div></pre></td></tr></table></figure>\n<h5 id=\"4-componentWillReceiveProps的作用，-会继续执行render吗？\"><a href=\"#4-componentWillReceiveProps的作用，-会继续执行render吗？\" class=\"headerlink\" title=\"4. componentWillReceiveProps的作用， 会继续执行render吗？\"></a>4. componentWillReceiveProps的作用， 会继续执行render吗？</h5><p><strong>A:</strong>   在组件接收到新的 props 的时候调用。在初始化渲染的时候，该方法不会调用。<br>用此函数可以作为 react 在 prop 传入之后， render() 渲染之前更新 state 的机会。老的 props 可以通过 this.props 获取到。在该函数中调用 this.setState() 将不会引起第二次渲染。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div></pre></td><td class=\"code\"><pre><div class=\"line\">var Hello = React.createClass(&#123;</div><div class=\"line\">    getInitialState: function () &#123;</div><div class=\"line\">        return &#123;name: &apos;parentNode&apos;&#125;;</div><div class=\"line\">    &#125;,</div><div class=\"line\">    clickBtn: function () &#123;</div><div class=\"line\">        this.setState(&#123;name: &apos;change ParentNode!&apos;&#125;);</div><div class=\"line\">    &#125;,</div><div class=\"line\">    render: function () &#123;</div><div class=\"line\">        return &lt;div className=&#123;this.state.name&#125;&gt;</div><div class=\"line\">            &lt;ChildNode name=&quot;parentNode&quot;/&gt;;</div><div class=\"line\">            &lt;button onClick=&#123;this.clickBtn&#125;&gt;点击&lt;/button&gt;</div><div class=\"line\">        &lt;/div&gt;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;);</div><div class=\"line\">var ChildNode = React.createClass(&#123;</div><div class=\"line\">    getDefaultProps: function () &#123;</div><div class=\"line\">        return &#123;name: &apos;childNode&apos;&#125;;</div><div class=\"line\">    &#125;,</div><div class=\"line\">    getInitialState: function () &#123;</div><div class=\"line\">        return &#123;message: &apos;welcome!&apos;&#125;;</div><div class=\"line\">    &#125;,</div><div class=\"line\">    componentDidMount: function () &#123;</div><div class=\"line\">        var childNode = document.getElementById(&apos;childId&apos;);</div><div class=\"line\">    &#125;,</div><div class=\"line\">    componentWillReceiveProps: function (nextProps) &#123;</div><div class=\"line\">        console.log(&apos;componentWillReceiveProps---&apos;+nextProps.name);</div><div class=\"line\">        console.log(&apos;componentWillReceiveProps---&apos;+ this.props.name);</div><div class=\"line\">        console.log(&apos;componentWillReceiveProps---&apos;+this.state.message);</div><div class=\"line\">        this.setState(&#123;message: &apos;change Welcome&apos;&#125;);</div><div class=\"line\"></div><div class=\"line\">    &#125;,</div><div class=\"line\">    render: function () &#123;</div><div class=\"line\">        console.log(&apos;render---&apos; + this.state.message);</div><div class=\"line\">        return &lt;div id=&quot;childId&quot;&gt;Hello &#123;this.props.name&#125; &#123;this.state.message&#125;&lt;/div&gt;;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">ReactDOM.render(</div><div class=\"line\">    &lt;Hello /&gt;,</div><div class=\"line\">    document.getElementById(&apos;container&apos;)</div><div class=\"line\">);</div></pre></td></tr></table></figure>\n<p>初始运行时：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">页面输出：</div><div class=\"line\">Hello parentNode welcome!</div><div class=\"line\"></div><div class=\"line\">制台输出:</div><div class=\"line\">render---welcome!</div></pre></td></tr></table></figure>\n<p>点击btn的是时：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">页面值：</div><div class=\"line\">Hello parentNode change Welcome</div><div class=\"line\"></div><div class=\"line\">控制台输出:</div><div class=\"line\">componentWillReceiveProps---parentNode</div><div class=\"line\">componentWillReceiveProps---parentNode</div><div class=\"line\">componentWillReceiveProps---welcome!</div><div class=\"line\">render---change Welcome</div></pre></td></tr></table></figure>\n<p><strong>官网总结：</strong></p>\n<p>当节点初次被放入的时候 componentWillReceiveProps 并不会被触发。这是故意这么设计的？</p>\n<p>原因是因为 componentWillReceiveProps 经常会处理一些和 old props 比较的逻辑，而且会在变化之前执行；不在组件即将渲染的时候触发，这也是这个方法设计的初衷。</p>\n<h5 id=\"5-immutableJS是如何解决shouldComponentUpdate中复杂对象的比较的？\"><a href=\"#5-immutableJS是如何解决shouldComponentUpdate中复杂对象的比较的？\" class=\"headerlink\" title=\"5. immutableJS是如何解决shouldComponentUpdate中复杂对象的比较的？\"></a>5. immutableJS是如何解决shouldComponentUpdate中复杂对象的比较的？</h5><p><strong>A:</strong><br>在shouldComponentUpdate分别判断props和state有没有变化。</p>\n<p>shouldComponentUpdate中使用immutableJS代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\">import &#123; is &#125; from &apos;immutable&apos;;</div><div class=\"line\"></div><div class=\"line\">shouldComponentUpdate: (nextProps = &#123;&#125;, nextState = &#123;&#125;) =&gt; &#123;</div><div class=\"line\">  const thisProps = this.props || &#123;&#125;, thisState = this.state || &#123;&#125;;</div><div class=\"line\"></div><div class=\"line\">  if (Object.keys(thisProps).length !== Object.keys(nextProps).length ||</div><div class=\"line\">      Object.keys(thisState).length !== Object.keys(nextState).length) &#123;</div><div class=\"line\">    return true;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  for (const key in nextProps) &#123;</div><div class=\"line\">    if (thisProps[key] !== nextProps[key] || is(thisProps[key], nextProps[key])) &#123;</div><div class=\"line\">      return true;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  for (const key in nextState) &#123;</div><div class=\"line\">    if (thisState[key] !== nextState[key] || is(thisState[key], nextState[key])) &#123;</div><div class=\"line\">      return true;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">  return false;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>is方法是先比较两个对象是不是同一个地址， 再比较两个对象的valueOf，即两个对象的值上否相同。<br>immutableJS中is实现代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\">export function is(valueA, valueB) &#123;</div><div class=\"line\">  if (valueA === valueB || (valueA !== valueA &amp;&amp; valueB !== valueB)) &#123;</div><div class=\"line\">    return true;</div><div class=\"line\">  &#125;</div><div class=\"line\">  if (!valueA || !valueB) &#123;</div><div class=\"line\">    return false;</div><div class=\"line\">  &#125;</div><div class=\"line\">  if (typeof valueA.valueOf === &apos;function&apos; &amp;&amp;</div><div class=\"line\">      typeof valueB.valueOf === &apos;function&apos;) &#123;</div><div class=\"line\">    valueA = valueA.valueOf();</div><div class=\"line\">    valueB = valueB.valueOf();</div><div class=\"line\">    if (valueA === valueB || (valueA !== valueA &amp;&amp; valueB !== valueB)) &#123;</div><div class=\"line\">      return true;</div><div class=\"line\">    &#125;</div><div class=\"line\">    if (!valueA || !valueB) &#123;</div><div class=\"line\">      return false;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">  if (typeof valueA.equals === &apos;function&apos; &amp;&amp;</div><div class=\"line\">      typeof valueB.equals === &apos;function&apos; &amp;&amp;</div><div class=\"line\">      valueA.equals(valueB)) &#123;</div><div class=\"line\">    return true;</div><div class=\"line\">  &#125;</div><div class=\"line\">  return false;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n","excerpt":"","more":"<h5 id=\"Q-reactjs为什么要设计成单向数据流？\"><a href=\"#Q-reactjs为什么要设计成单向数据流？\" class=\"headerlink\" title=\"Q: reactjs为什么要设计成单向数据流？\"></a>Q: reactjs为什么要设计成单向数据流？</h5><p><strong>A</strong>：”在React中，数据流向是单向的——从父节点传递到子节点，因而组件是简单且易于把握的，他们只需从父节点获取props渲染即可。如果顶层组件的某个prop改变了，React会递归地向下遍历整棵组建树，重新渲染所有使用这个属性的组件。”</p>\n<p>个人觉得这个解释不是很全面，搜到一个相关文章<a href=\"http://karynsong.github.io/2016-02/38/\">React 单向数据流分析</a>，但是讲得也不是很清楚， 我觉得可以看完Redux再回过来总结这个问题。</p>\n<h5 id=\"Q-外部传入的props与getDefaultProps的关系，是谁覆盖谁？\"><a href=\"#Q-外部传入的props与getDefaultProps的关系，是谁覆盖谁？\" class=\"headerlink\" title=\"Q. 外部传入的props与getDefaultProps的关系，是谁覆盖谁？\"></a>Q. 外部传入的props与getDefaultProps的关系，是谁覆盖谁？</h5><p><strong>A:</strong> 外部传入的props与getDefaultProps的关系是外部传入的props属性覆盖getDefaultProps。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\">var Hello = React.createClass(&#123;</div><div class=\"line\">  render: function() &#123;</div><div class=\"line\">    return &lt;ChildNode name=&quot;parentNode&quot; /&gt;;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;);</div><div class=\"line\">var ChildNode = React.createClass(&#123;</div><div class=\"line\"> getDefaultProps: function() &#123;</div><div class=\"line\">  \treturn &#123;name: &apos;childNode&apos;&#125;;</div><div class=\"line\">  &#125;,</div><div class=\"line\">  render: function() &#123;</div><div class=\"line\">    return &lt;div&gt;Hello &#123;this.props.name&#125;&lt;/div&gt;;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">ReactDOM.render(</div><div class=\"line\">  &lt;Hello /&gt;,</div><div class=\"line\">  document.getElementById(&apos;container&apos;)</div><div class=\"line\">);</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">//输出</div><div class=\"line\">Hello parentNode</div></pre></td></tr></table></figure>\n<h5 id=\"Q-生命周期的componentDidMount时期是否已经插入了DOM？\"><a href=\"#Q-生命周期的componentDidMount时期是否已经插入了DOM？\" class=\"headerlink\" title=\"Q. 生命周期的componentDidMount时期是否已经插入了DOM？\"></a>Q. 生命周期的componentDidMount时期是否已经插入了DOM？</h5><p><strong>A:</strong> componentDidMount时期已经插入了DOM，</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\">var Hello = React.createClass(&#123;</div><div class=\"line\">  render: function() &#123;</div><div class=\"line\">    return &lt;ChildNode name=&quot;parentNode&quot; /&gt;;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;);</div><div class=\"line\">var ChildNode = React.createClass(&#123;</div><div class=\"line\">\tgetDefaultProps: function() &#123;</div><div class=\"line\">  \tconsole.log(123);</div><div class=\"line\">  \treturn &#123;name: &apos;childNode&apos;&#125;;</div><div class=\"line\">  &#125;,</div><div class=\"line\">  componentDidMount: function() &#123;</div><div class=\"line\">  \tvar childNode = document.getElementById(&apos;childId&apos;);</div><div class=\"line\">    console.log(childNode);</div><div class=\"line\">  &#125;,</div><div class=\"line\">  render: function() &#123;</div><div class=\"line\">    return &lt;div id=&quot;childId&quot;&gt;Hello &#123;this.props.name&#125;&lt;/div&gt;;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">ReactDOM.render(</div><div class=\"line\">  &lt;Hello /&gt;,</div><div class=\"line\">  document.getElementById(&apos;container&apos;)</div><div class=\"line\">);</div></pre></td></tr></table></figure>\n<p>控制台输出:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;div data-reactroot=&quot;&quot; id=&quot;childId&quot;&gt;</div><div class=\"line\">&lt;!-- react-text: 2 --&gt;</div><div class=\"line\">Hello </div><div class=\"line\">&lt;!-- /react-text --&gt;</div><div class=\"line\">&lt;!-- react-text: 3 --&gt;</div><div class=\"line\">parentNode</div><div class=\"line\">&lt;!-- /react-text --&gt;</div><div class=\"line\">&lt;/div&gt;</div></pre></td></tr></table></figure>\n<h5 id=\"4-componentWillReceiveProps的作用，-会继续执行render吗？\"><a href=\"#4-componentWillReceiveProps的作用，-会继续执行render吗？\" class=\"headerlink\" title=\"4. componentWillReceiveProps的作用， 会继续执行render吗？\"></a>4. componentWillReceiveProps的作用， 会继续执行render吗？</h5><p><strong>A:</strong>   在组件接收到新的 props 的时候调用。在初始化渲染的时候，该方法不会调用。<br>用此函数可以作为 react 在 prop 传入之后， render() 渲染之前更新 state 的机会。老的 props 可以通过 this.props 获取到。在该函数中调用 this.setState() 将不会引起第二次渲染。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div></pre></td><td class=\"code\"><pre><div class=\"line\">var Hello = React.createClass(&#123;</div><div class=\"line\">    getInitialState: function () &#123;</div><div class=\"line\">        return &#123;name: &apos;parentNode&apos;&#125;;</div><div class=\"line\">    &#125;,</div><div class=\"line\">    clickBtn: function () &#123;</div><div class=\"line\">        this.setState(&#123;name: &apos;change ParentNode!&apos;&#125;);</div><div class=\"line\">    &#125;,</div><div class=\"line\">    render: function () &#123;</div><div class=\"line\">        return &lt;div className=&#123;this.state.name&#125;&gt;</div><div class=\"line\">            &lt;ChildNode name=&quot;parentNode&quot;/&gt;;</div><div class=\"line\">            &lt;button onClick=&#123;this.clickBtn&#125;&gt;点击&lt;/button&gt;</div><div class=\"line\">        &lt;/div&gt;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;);</div><div class=\"line\">var ChildNode = React.createClass(&#123;</div><div class=\"line\">    getDefaultProps: function () &#123;</div><div class=\"line\">        return &#123;name: &apos;childNode&apos;&#125;;</div><div class=\"line\">    &#125;,</div><div class=\"line\">    getInitialState: function () &#123;</div><div class=\"line\">        return &#123;message: &apos;welcome!&apos;&#125;;</div><div class=\"line\">    &#125;,</div><div class=\"line\">    componentDidMount: function () &#123;</div><div class=\"line\">        var childNode = document.getElementById(&apos;childId&apos;);</div><div class=\"line\">    &#125;,</div><div class=\"line\">    componentWillReceiveProps: function (nextProps) &#123;</div><div class=\"line\">        console.log(&apos;componentWillReceiveProps---&apos;+nextProps.name);</div><div class=\"line\">        console.log(&apos;componentWillReceiveProps---&apos;+ this.props.name);</div><div class=\"line\">        console.log(&apos;componentWillReceiveProps---&apos;+this.state.message);</div><div class=\"line\">        this.setState(&#123;message: &apos;change Welcome&apos;&#125;);</div><div class=\"line\"></div><div class=\"line\">    &#125;,</div><div class=\"line\">    render: function () &#123;</div><div class=\"line\">        console.log(&apos;render---&apos; + this.state.message);</div><div class=\"line\">        return &lt;div id=&quot;childId&quot;&gt;Hello &#123;this.props.name&#125; &#123;this.state.message&#125;&lt;/div&gt;;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">ReactDOM.render(</div><div class=\"line\">    &lt;Hello /&gt;,</div><div class=\"line\">    document.getElementById(&apos;container&apos;)</div><div class=\"line\">);</div></pre></td></tr></table></figure>\n<p>初始运行时：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">页面输出：</div><div class=\"line\">Hello parentNode welcome!</div><div class=\"line\"></div><div class=\"line\">制台输出:</div><div class=\"line\">render---welcome!</div></pre></td></tr></table></figure>\n<p>点击btn的是时：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">页面值：</div><div class=\"line\">Hello parentNode change Welcome</div><div class=\"line\"></div><div class=\"line\">控制台输出:</div><div class=\"line\">componentWillReceiveProps---parentNode</div><div class=\"line\">componentWillReceiveProps---parentNode</div><div class=\"line\">componentWillReceiveProps---welcome!</div><div class=\"line\">render---change Welcome</div></pre></td></tr></table></figure>\n<p><strong>官网总结：</strong></p>\n<p>当节点初次被放入的时候 componentWillReceiveProps 并不会被触发。这是故意这么设计的？</p>\n<p>原因是因为 componentWillReceiveProps 经常会处理一些和 old props 比较的逻辑，而且会在变化之前执行；不在组件即将渲染的时候触发，这也是这个方法设计的初衷。</p>\n<h5 id=\"5-immutableJS是如何解决shouldComponentUpdate中复杂对象的比较的？\"><a href=\"#5-immutableJS是如何解决shouldComponentUpdate中复杂对象的比较的？\" class=\"headerlink\" title=\"5. immutableJS是如何解决shouldComponentUpdate中复杂对象的比较的？\"></a>5. immutableJS是如何解决shouldComponentUpdate中复杂对象的比较的？</h5><p><strong>A:</strong><br>在shouldComponentUpdate分别判断props和state有没有变化。</p>\n<p>shouldComponentUpdate中使用immutableJS代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\">import &#123; is &#125; from &apos;immutable&apos;;</div><div class=\"line\"></div><div class=\"line\">shouldComponentUpdate: (nextProps = &#123;&#125;, nextState = &#123;&#125;) =&gt; &#123;</div><div class=\"line\">  const thisProps = this.props || &#123;&#125;, thisState = this.state || &#123;&#125;;</div><div class=\"line\"></div><div class=\"line\">  if (Object.keys(thisProps).length !== Object.keys(nextProps).length ||</div><div class=\"line\">      Object.keys(thisState).length !== Object.keys(nextState).length) &#123;</div><div class=\"line\">    return true;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  for (const key in nextProps) &#123;</div><div class=\"line\">    if (thisProps[key] !== nextProps[key] || is(thisProps[key], nextProps[key])) &#123;</div><div class=\"line\">      return true;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  for (const key in nextState) &#123;</div><div class=\"line\">    if (thisState[key] !== nextState[key] || is(thisState[key], nextState[key])) &#123;</div><div class=\"line\">      return true;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">  return false;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>is方法是先比较两个对象是不是同一个地址， 再比较两个对象的valueOf，即两个对象的值上否相同。<br>immutableJS中is实现代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\">export function is(valueA, valueB) &#123;</div><div class=\"line\">  if (valueA === valueB || (valueA !== valueA &amp;&amp; valueB !== valueB)) &#123;</div><div class=\"line\">    return true;</div><div class=\"line\">  &#125;</div><div class=\"line\">  if (!valueA || !valueB) &#123;</div><div class=\"line\">    return false;</div><div class=\"line\">  &#125;</div><div class=\"line\">  if (typeof valueA.valueOf === &apos;function&apos; &amp;&amp;</div><div class=\"line\">      typeof valueB.valueOf === &apos;function&apos;) &#123;</div><div class=\"line\">    valueA = valueA.valueOf();</div><div class=\"line\">    valueB = valueB.valueOf();</div><div class=\"line\">    if (valueA === valueB || (valueA !== valueA &amp;&amp; valueB !== valueB)) &#123;</div><div class=\"line\">      return true;</div><div class=\"line\">    &#125;</div><div class=\"line\">    if (!valueA || !valueB) &#123;</div><div class=\"line\">      return false;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">  if (typeof valueA.equals === &apos;function&apos; &amp;&amp;</div><div class=\"line\">      typeof valueB.equals === &apos;function&apos; &amp;&amp;</div><div class=\"line\">      valueA.equals(valueB)) &#123;</div><div class=\"line\">    return true;</div><div class=\"line\">  &#125;</div><div class=\"line\">  return false;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cis4l3qsy00001hp4lplptab3","category_id":"cis4l3qts00051hp45tfnpe1w","_id":"cis4l3qu4000a1hp4rq9aosvc"},{"post_id":"cis4l3qtc00021hp47gca4spm","category_id":"cis4l3qtz00081hp4x0s0h9zq","_id":"cis4l3qu6000e1hp4mr30849g"},{"post_id":"cis4l3qtu00061hp46gprhero","category_id":"cis4l3qu5000c1hp492zw6nqg","_id":"cis4l3qu7000g1hp4fak1h2vq"}],"PostTag":[{"post_id":"cis4l3qsy00001hp4lplptab3","tag_id":"cis4l3qtk00041hp4l0igtq8h","_id":"cis4l3qu000091hp476v9eegj"},{"post_id":"cis4l3qtc00021hp47gca4spm","tag_id":"cis4l3qty00071hp4kp01krmd","_id":"cis4l3qu6000d1hp40wmmptee"},{"post_id":"cis4l3qtu00061hp46gprhero","tag_id":"cis4l3qu4000b1hp4p4ckin2v","_id":"cis4l3qu7000f1hp4424dw6j0"}],"Tag":[{"name":"ES6","_id":"cis4l3qtk00041hp4l0igtq8h"},{"name":"技术","_id":"cis4l3qty00071hp4kp01krmd"},{"name":"ReactJS","_id":"cis4l3qu4000b1hp4p4ckin2v"}]}}